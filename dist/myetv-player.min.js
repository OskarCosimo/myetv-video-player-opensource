

class VideoPlayerI18n {
 constructor() {

 this.translations = {

 'it': {
 'subtitles': 'Sottotitoli (C)',
 'subtitlesdisable': 'Disabilita Sottotitoli',
 'subtitlesenable': 'Abilita Sottotitoli',
 'play_pause': 'Play/Pausa (Spazio)',
 'mute_unmute': 'Muta/Smuta (M)',
 'volume': 'Volume',
 'playback_speed': 'Velocità riproduzione',
 'video_quality': 'Qualità video',
 'picture_in_picture': 'Picture-in-Picture (P)',
 'fullscreen': 'Schermo intero (F)',
 'auto': 'Auto',
 'brand_logo': 'Logo',
 'next_video': 'Video successivo (N)',
 'prev_video': 'Video precedente (P)',
 'playlist_next': 'Avanti',
 'playlist_prev': 'Indietro',
 'settings_menu': 'Impostazioni'
 },

 'en': {
 'subtitles': 'Subtitles (C)',
 'subtitlesdisable': 'Disable Subtitles',
 'subtitlesenable': 'Enable Subtitles',
 'play_pause': 'Play/Pause (Space)',
 'mute_unmute': 'Mute/Unmute (M)',
 'volume': 'Volume',
 'playback_speed': 'Playback speed',
 'video_quality': 'Video quality',
 'picture_in_picture': 'Picture-in-Picture (P)',
 'fullscreen': 'Fullscreen (F)',
 'auto': 'Auto',
 'brand_logo': 'Brand logo',
 'next_video': 'Next video (N)',
 'prev_video': 'Previous video (P)',
 'playlist_next': 'Next',
 'playlist_prev': 'Previous',
 'next_video': 'Next video (N)',
 'prev_video': 'Previous video (P)',
 'playlist_next': 'Next',
 'playlist_prev': 'Previous',
 'settings_menu': 'Settings'
 },

 'es': {
 'subtitles': 'Subtítulos (C)',
 'subtitlesdisable': 'Disable Subtitles',
 'subtitlesenable': 'Enable Subtitles',
 'play_pause': 'Reproducir/Pausar (Espacio)',
 'mute_unmute': 'Silenciar (M)',
 'volume': 'Volumen',
 'playback_speed': 'Velocidad de reproducción',
 'video_quality': 'Calidad de vídeo',
 'picture_in_picture': 'Picture-in-Picture (P)',
 'fullscreen': 'Pantalla completa (F)',
 'auto': 'Auto',
 'brand_logo': 'Logo de marca',
 'next_video': 'Siguiente vídeo (N)',
 'prev_video': 'Vídeo anterior (P)',
 'playlist_next': 'Siguiente',
 'playlist_prev': 'Anterior',
 'settings_menu': 'Settings'
 },

 'fr': {
 'subtitles': 'Sous-titres (C)',
 'subtitlesdisable': 'Disable Subtitles',
 'subtitlesenable': 'Enable Subtitles',
 'play_pause': 'Lecture/Pause (Espace)',
 'mute_unmute': 'Muet (M)',
 'volume': 'Volume',
 'playback_speed': 'Vitesse de lecture',
 'video_quality': 'Qualité vidéo',
 'picture_in_picture': 'Picture-in-Picture (P)',
 'fullscreen': 'Plein écran (F)',
 'auto': 'Auto',
 'brand_logo': 'Logo de marque',
 'next_video': 'Vidéo suivante (N)',
 'prev_video': 'Vidéo précédente (P)',
 'playlist_next': 'Suivant',
 'playlist_prev': 'Précédent',
 'settings_menu': 'Settings'
 },

 'de': {
 'subtitles': 'Untertitel (C)',
 'subtitlesdisable': 'Disable Subtitles',
 'subtitlesenable': 'Enable Subtitles',
 'play_pause': 'Abspielen/Pausieren (Leertaste)',
 'mute_unmute': 'Stumm (M)',
 'volume': 'Lautstärke',
 'playback_speed': 'Wiedergabegeschwindigkeit',
 'video_quality': 'Videoqualität',
 'picture_in_picture': 'Picture-in-Picture (P)',
 'fullscreen': 'Vollbild (F)',
 'auto': 'Auto',
 'brand_logo': 'Markenlogo',
 'next_video': 'Nächstes Video (N)',
 'prev_video': 'Vorheriges Video (P)',
 'playlist_next': 'Weiter',
 'playlist_prev': 'Zurück',
 'settings_menu': 'Settings'
 },

 'pt': {
 'subtitles': 'Legendas (C)',
 'subtitlesdisable': 'Disable Subtitles',
 'subtitlesenable': 'Enable Subtitles',
 'play_pause': 'Reproduzir/Pausar (Espaço)',
 'mute_unmute': 'Silenciar (M)',
 'volume': 'Volume',
 'playback_speed': 'Velocidade de reprodução',
 'video_quality': 'Qualidade do vídeo',
 'picture_in_picture': 'Picture-in-Picture (P)',
 'fullscreen': 'Tela cheia (F)',
 'auto': 'Auto',
 'brand_logo': 'Logo da marca',
 'next_video': 'Próximo vídeo (N)',
 'prev_video': 'Vídeo anterior (P)',
 'playlist_next': 'Próximo',
 'playlist_prev': 'Anterior',
 'settings_menu': 'Settings'
 },

 'zh': {
 'subtitles': '字幕 (C)',
 'subtitlesdisable': 'Disable Subtitles',
 'subtitlesenable': 'Enable Subtitles',
 'play_pause': '播放/暂停 (空格)',
 'mute_unmute': '静音 (M)',
 'volume': '音量',
 'playback_speed': '播放速度',
 'video_quality': '视频质量',
 'picture_in_picture': '画中画 (P)',
 'fullscreen': '全屏 (F)',
 'auto': '自动',
 'brand_logo': '品牌标志',
 'next_video': '下一个视频 (N)',
 'prev_video': '上一个视频 (P)',
 'playlist_next': '下一个',
 'playlist_prev': '上一个',
 'settings_menu': 'Settings'
 },

 'ja': {
 'subtitles': '字幕 (C)',
 'subtitlesdisable': 'Disable Subtitles',
 'subtitlesenable': 'Enable Subtitles',
 'play_pause': '再生/一時停止 (スペース)',
 'mute_unmute': 'ミュート (M)',
 'volume': '音量',
 'playback_speed': '再生速度',
 'video_quality': '動画品質',
 'picture_in_picture': 'ピクチャーインピクチャー (P)',
 'fullscreen': 'フルスクリーン (F)',
 'auto': '自動',
 'brand_logo': 'ブランドロゴ',
 'next_video': '次の動画 (N)',
 'prev_video': '前の動画 (P)',
 'playlist_next': '次へ',
 'playlist_prev': '前へ',
 'settings_menu': 'Settings'
 },

 'ru': {
 'subtitles': 'Субтитры (C)',
 'subtitlesdisable': 'Disable Subtitles',
 'subtitlesenable': 'Enable Subtitles',
 'play_pause': 'Воспроизведение/Пауза (Пробел)',
 'mute_unmute': 'Звук (M)',
 'volume': 'Громкость',
 'playback_speed': 'Скорость воспроизведения',
 'video_quality': 'Качество видео',
 'picture_in_picture': 'Картинка в картинке (P)',
 'fullscreen': 'Полный экран (F)',
 'auto': 'Авто',
 'brand_logo': 'Логотип бренда',
 'next_video': 'Следующее видео (N)',
 'prev_video': 'Предыдущее видео (P)',
 'playlist_next': 'Далее',
 'playlist_prev': 'Назад',
 'settings_menu': 'Settings'
 },

 'ar': {
 'subtitles': 'الترجمة (C)',
 'subtitlesdisable': 'Disable Subtitles',
 'subtitlesenable': 'Enable Subtitles',
 'play_pause': 'تشغيل/إيقاف مؤقت (مسافة)',
 'mute_unmute': 'كتم الصوت (M)',
 'volume': 'مستوى الصوت',
 'playback_speed': 'سرعة التشغيل',
 'video_quality': 'جودة الفيديو',
 'picture_in_picture': 'صورة في صورة (P)',
 'fullscreen': 'ملء الشاشة (F)',
 'auto': 'تلقائي',
 'brand_logo': 'شعار العلامة التجارية',
 'next_video': 'الفيديو التالي (N)',
 'prev_video': 'الفيديو السابق (P)',
 'playlist_next': 'التالي',
 'playlist_prev': 'السابق',
 'settings_menu': 'Settings'
 }
 };

 this.currentLanguage = this.detectLanguage();
 }

 detectLanguage() {
 try {
 const lang = navigator.language || navigator.userLanguage || 'en';
 const shortLang = lang.split('-')[0].toLowerCase();

 return this.translations[shortLang] ? shortLang : 'en';
 } catch (error) {
 console.warn('Language detection error:', error);
 return 'en';
 }
 }

 t(key) {
 try {
 return this.translations[this.currentLanguage]?.[key] ||
 this.translations['en']?.[key] ||
 key;
 } catch (error) {
 console.warn('Translation error for key:', key, error);
 return key;
 }
 }

 setLanguage(lang) {
 try {
 if (this.translations[lang]) {
 this.currentLanguage = lang;
 return true;
 }
 return false;
 } catch (error) {
 console.warn('Language change error:', error);
 return false;
 }
 }

 getSupportedLanguages() {
 try {
 return Object.keys(this.translations);
 } catch (error) {
 console.warn('Error getting languages:', error);
 return ['en'];
 }
 }

 getCurrentLanguage() {
 return this.currentLanguage || 'en';
 }

 addTranslations(lang, translations) {
 try {

 if (!this.isValidLanguageKey(lang)) {
 console.warn('Invalid language key rejected:', lang);
 return;
 }

 if (!this.translations[lang]) {
 this.translations[lang] = {};
 }

 for (const key in translations) {
 if (translations.hasOwnProperty(key) && this.isValidLanguageKey(key)) {
 this.translations[lang][key] = translations[key];
 }
 }
 } catch (error) {
 console.warn('Error adding translations:', error);
 }
 }

 isValidLanguageKey(key) {
 if (typeof key !== 'string') return false;

 const dangerousKeys = ['__proto__', 'constructor', 'prototype'];
 if (dangerousKeys.includes(key.toLowerCase())) {
 return false;
 }

 return /^[a-zA-Z0-9_-]+$/.test(key);
 }
}

let VideoPlayerTranslations;

try {
 VideoPlayerTranslations = new VideoPlayerI18n();
} catch (error) {
 console.warn('i18n initialization error, using fallback:', error);

 VideoPlayerTranslations = {
 currentLanguage: 'en',
 t: function (key) {
 const fallback = {
 'subtitles': 'Subtitles (C)',
 'subtitlesdisable': 'Disable Subtitles',
 'subtitlesenable': 'Enable Subtitles',
 'play_pause': 'Play/Pause (Space)',
 'mute_unmute': 'Mute/Unmute (M)',
 'volume': 'Volume',
 'playback_speed': 'Playback speed',
 'video_quality': 'Video quality',
 'picture_in_picture': 'Picture-in-Picture (P)',
 'fullscreen': 'Fullscreen (F)',
 'auto': 'Auto',
 'brand_logo': 'Brand logo',
 'settings_menu': 'Settings'
 };
 return fallback[key] || key;
 },
 setLanguage: function () { return false; },
 getCurrentLanguage: function () { return 'en'; },
 getSupportedLanguages: function () { return ['en']; }
 };
}

function t(key) {
 try {
 return VideoPlayerTranslations.t(key);
 } catch (error) {
 console.warn('Helper t() error:', error);
 return key;
 }
}

if (typeof window !== 'undefined') {
 window.VideoPlayerTranslations = VideoPlayerTranslations;
 window.t = t;
}

if (!window.MYETVPlayerPlugins) {
 window.MYETVPlayerPlugins = {};
}

function registerPlugin(name, plugin) {
 if (window.MYETVPlayerPlugins[name]) {
 console.warn(`Plugin "${name}" is already registered. Overwriting...`);
 }

 window.MYETVPlayerPlugins[name] = plugin;

 if (typeof console !== 'undefined') {
 console.log(`🔌 Plugin "${name}" registered globally`);
 }
}
window.registerMYETVPlugin = registerPlugin;

class MYETVvideoplayer {

constructor(videoElement, options = {}) {
 this.video = typeof videoElement === 'string'
 ? document.getElementById(videoElement)
 : videoElement;

 if (!this.video) {
 throw new Error('Video element not found: ' + videoElement);
 }

 this.options = {
 showQualitySelector: true,
 showSpeedControl: true,
 showFullscreen: true,
 showPictureInPicture: true,
 showSubtitles: true,
 subtitlesEnabled: false,
 autoHide: true,
 autoHideDelay: 3000,
 poster: null, // URL of poster image
 showPosterOnEnd: false, // Show poster again when video ends
 keyboardControls: true,
 showSeekTooltip: true,
 showTitleOverlay: false,
 videoTitle: '',
 videoSubtitle: '',
 persistentTitle: false,
 debug: false, // Enable/disable debug logging
 autoplay: false, // if video should autoplay at start
 defaultQuality: 'auto', // 'auto', '1080p', '720p', '480p', etc.
 language: null, // language of the player (default english)
 pauseClick: true, // the player should be paused when click over the video area
 doubleTapPause: true, // first tap (or click) show the controlbar, second tap (or click) pause
 brandLogoEnabled: false, // Enable/disable brand logo
 brandLogoUrl: '', // URL for brand logo image
 brandLogoLinkUrl: '', // Optional URL to open when clicking the logo
 brandLogoTooltipText: '', // Tooltip text for brand logo
 playlistEnabled: true, // Enable/disable playlist detection
 playlistAutoPlay: true, // Auto-play next video when current ends
 playlistLoop: false, // Loop playlist when reaching the end
 loop: false, // Loop video when it ends (restart from beginning)
 volumeSlider: 'show', // Mobile volume slider: 'show' (horizontal popup) or 'hide' (no slider on mobile)

 watermarkUrl: '', // URL of watermark image
 watermarkLink: '', // Optional URL to open when clicking watermark
 watermarkPosition: 'bottomright', // Position: topleft, topright, bottomleft, bottomright
 watermarkTitle: '', // Optional tooltip title
 hideWatermark: true, // Hide watermark with controls (default: true)

 adaptiveStreaming: false, // Enable DASH/HLS adaptive streaming
 dashLibUrl: 'https://cdn.dashjs.org/latest/dash.all.min.js', // Dash.js library URL
 hlsLibUrl: 'https://cdn.jsdelivr.net/npm/hls.js@latest', // HLS.js library URL
 adaptiveQualityControl: true, // Show quality control for adaptive streams

 seekHandleShape: 'circle', // Available shape: none, circle, square, diamond, arrow, triangle, heart, star

 audiofile: false,
 audiowave: false,

 resolution: "normal", // "normal", "4:3", "16:9", "stretched", "fit-to-screen", "scale-to-fit"
 ...options
 };

 this.isUserSeeking = false;
 this.controlsTimeout = null;
 this.titleTimeout = null;
 this.currentQualityIndex = 0;
 this.qualities = [];
 this.originalSources = [];
 this.isPiPSupported = this.checkPiPSupport();
 this.seekTooltip = null;
 this.titleOverlay = null;
 this.isPlayerReady = false;

 this.textTracks = [];
 this.currentSubtitleTrack = null;
 this.subtitlesEnabled = false;
 this.customSubtitleRenderer = null;

 this.chapters = [];
 this.chapterMarkersContainer = null;
 this.chapterTooltip = null;

 this.selectedQuality = this.options.defaultQuality || 'auto';
 this.currentPlayingQuality = null;
 this.qualityMonitorInterval = null;

 this.qualityChangeTimeout = null;
 this.isChangingQuality = false;

 this.debugQuality = false;

 this.autoHideTimer = null;
 this.mouseOverControls = false;
 this.autoHideDebug = false;
 this.autoHideInitialized = false;

 this.posterOverlay = null;

 this.watermarkElement = null;

 this.eventCallbacks = {

 'playerready': [], // Fired when player is fully initialized and ready
 'played': [], // Fired when video starts playing
 'paused': [], // Fired when video is paused
 'ended': [], // Fired when video playback ends

 'playing': [], // Fired when video is actually playing (after buffering)
 'waiting': [], // Fired when video is waiting for data (buffering)
 'seeking': [], // Fired when seek operation starts
 'seeked': [], // Fired when seek operation completes

 'loadstart': [], // Fired when browser starts looking for media
 'loadedmetadata': [], // Fired when metadata (duration, dimensions) is loaded
 'loadeddata': [], // Fired when data for current frame is loaded
 'canplay': [], // Fired when browser can start playing video
 'progress': [], // Fired periodically while downloading media
 'durationchange': [], // Fired when duration attribute changes

 'error': [], // Fired when media loading or playback error occurs
 'stalled': [], // Fired when browser is trying to get data but it's not available

 'timeupdate': [], // Fired when current playback position changes
 'volumechange': [], // Fired when volume or muted state changes
 'speedchange': [], // Fired when playback speed changes
 'qualitychange': [], // Fired when video quality changes

 'subtitlechange': [], // Fired when subtitle track changes
 'chapterchange': [], // Fired when video chapter changes
 'pipchange': [], // Fired when picture-in-picture mode changes
 'fullscreenchange': [], // Fired when fullscreen mode changes
 'playlistchange': [] // Fired when playlist item changes
 };

 this.playlist = [];
 this.currentPlaylistIndex = -1;
 this.playlistId = null;
 this.isPlaylistActive = false;

 this.dashPlayer = null;
 this.hlsPlayer = null;
 this.adaptiveStreamingType = null; // 'dash', 'hls', or null
 this.isAdaptiveStream = false;
 this.adaptiveQualities = [];
 this.librariesLoaded = {
 dash: false,
 hls: false
 };

 this.lastTimeUpdate = 0; // For throttling timeupdate events

 if (this.options.language && this.isI18nAvailable()) {
 VideoPlayerTranslations.setLanguage(this.options.language);
 }

 if (options.autoplay) {
 this.video.autoplay = true;
 }

 try {
 this.interceptAutoLoading();
 this.createPlayerStructure();
 this.initializeElements();
 this.setupMenuToggles(); // Initialize menu toggle system

 this.adaptToAudioFile = function () {
 if (this.options.audiofile) {

 if (this.video) {
 this.video.style.display = 'none';
 }
 if (this.container) {
 this.container.classList.add('audio-player');
 }
 if (this.options.audiowave) {
 this.initAudioWave();
 }
 }
 };

 this.initAudioWave = function () {
 if (!this.video) return;

 this.audioWaveCanvas = document.createElement('canvas');
 this.audioWaveCanvas.className = 'audio-wave-canvas';
 this.container.appendChild(this.audioWaveCanvas);

 const canvasCtx = this.audioWaveCanvas.getContext('2d');
 const WIDTH = this.audioWaveCanvas.width = this.container.clientWidth;
 const HEIGHT = this.audioWaveCanvas.height = 60; // altezza onda audio

 const AudioContext = window.AudioContext || window.webkitAudioContext;
 this.audioCtx = new AudioContext();
 this.analyser = this.audioCtx.createAnalyser();
 this.source = this.audioCtx.createMediaElementSource(this.video);
 this.source.connect(this.analyser);
 this.analyser.connect(this.audioCtx.destination);

 this.analyser.fftSize = 2048;
 const bufferLength = this.analyser.fftSize;
 const dataArray = new Uint8Array(bufferLength);

 const draw = () => {
 requestAnimationFrame(draw);
 this.analyser.getByteTimeDomainData(dataArray);

 canvasCtx.fillStyle = '#222';
 canvasCtx.fillRect(0, 0, WIDTH, HEIGHT);

 canvasCtx.lineWidth = 2;
 canvasCtx.strokeStyle = '#33ccff';
 canvasCtx.beginPath();

 const sliceWidth = WIDTH / bufferLength;
 let x = 0;

 for (let i = 0; i < bufferLength; i++) {
 const v = dataArray[i] / 128.0;
 const y = v * HEIGHT / 2;

 if (i === 0) {
 canvasCtx.moveTo(x, y);
 } else {
 canvasCtx.lineTo(x, y);
 }

 x += sliceWidth;
 }
 canvasCtx.lineTo(WIDTH, HEIGHT / 2);
 canvasCtx.stroke();
 };

 draw();
 };
 this.adaptToAudioFile();
 this.bindEvents();

 if (this.options.keyboardControls) {
 this.setupKeyboardControls();
 }

 this.updateVolumeSliderVisual();
 this.initVolumeTooltip();
 this.updateTooltips();
 this.markPlayerReady();
 this.initializePluginSystem();
 this.restoreSourcesAsync();

 this.initializeSubtitles();
 this.initializeQualityMonitoring();

 this.initializeResolution();
 this.initializeChapters();
 this.initializePoster();
 this.initializeWatermark();

 } catch (error) {
 if (this.options.debug) console.error('Video player initialization error:', error);
 }
}

getPlayerState() {
 return {
 isPlaying: !this.isPaused(),
 isPaused: this.isPaused(),
 currentTime: this.getCurrentTime(),
 duration: this.getDuration(),
 volume: this.getVolume(),
 isMuted: this.isMuted(),
 playbackRate: this.getPlaybackRate(),
 isFullscreen: this.isFullscreenActive(),
 isPictureInPicture: this.isPictureInPictureActive(),
 subtitlesEnabled: this.isSubtitlesEnabled(),
 currentSubtitle: this.getCurrentSubtitleTrack(),
 selectedQuality: this.getSelectedQuality(),
 currentQuality: this.getCurrentPlayingQuality(),
 isAutoQuality: this.isAutoQualityActive()
 };
}

isI18nAvailable() {
 return typeof VideoPlayerTranslations !== 'undefined' &&
 VideoPlayerTranslations !== null &&
 typeof VideoPlayerTranslations.t === 'function';
}

t(key) {
 if (this.isI18nAvailable()) {
 try {
 return VideoPlayerTranslations.t(key);
 } catch (error) {
 if (this.options.debug) console.warn('Translation error:', error);
 }
 }

 const fallback = {
 'play_pause': 'Play/Pause (Space)',
 'mute_unmute': 'Mute/Unmute (M)',
 'volume': 'Volume',
 'playback_speed': 'Playback speed',
 'video_quality': 'Video quality',
 'picture_in_picture': 'Picture-in-Picture (P)',
 'fullscreen': 'Fullscreen (F)',
 'subtitles': 'Subtitles (S)',
 'subtitles_enable': 'Enable subtitles',
 'subtitles_disable': 'Disable subtitles',
 'subtitles_off': 'Off',
 'auto': 'Auto',
 'brand_logo': 'Brand logo',
 'next_video': 'Next video (N)',
 'prev_video': 'Previous video (P)',
 'playlist_next': 'Next',
 'playlist_prev': 'Previous'
 };

 return fallback[key] || key;
}

interceptAutoLoading() {
 this.saveOriginalSources();
 this.disableSources();

 this.video.preload = 'none';
 this.video.controls = false;
 this.video.autoplay = false;

 if (this.video.src && this.video.src !== window.location.href) {
 this.originalSrc = this.video.src;
 this.video.removeAttribute('src');
 this.video.src = '';
 }

 this.hideNativePlayer();

 if (this.options.debug) console.log('📁 Sources temporarily disabled to prevent blocking');
}

saveOriginalSources() {
 const sources = this.video.querySelectorAll('source');
 this.originalSources = [];

 sources.forEach((source, index) => {
 if (source.src) {
 this.originalSources.push({
 element: source,
 src: source.src,
 type: source.type || 'video/mp4',
 quality: source.getAttribute('data-quality') || `quality-${index}`,
 index: index
 });
 }
 });

 if (this.options.debug) console.log(`📁 Saved ${this.originalSources.length} sources originali:`, this.originalSources);
}

disableSources() {
 const sources = this.video.querySelectorAll('source');
 sources.forEach(source => {
 if (source.src) {
 source.removeAttribute('src');
 }
 });
}

restoreSourcesAsync() {
 setTimeout(() => {
 this.restoreSources();
 }, 200);
}

 async restoreSources() {
 try {

 let adaptiveSource = null;

 if (this.originalSrc) {
 adaptiveSource = this.originalSrc;
 } else if (this.originalSources.length > 0) {

 const firstSource = this.originalSources[0];
 if (firstSource.src && this.detectStreamType(firstSource.src)) {
 adaptiveSource = firstSource.src;
 }
 }

 if (adaptiveSource && this.options.adaptiveStreaming) {
 const adaptiveInitialized = await this.initializeAdaptiveStreaming(adaptiveSource);
 if (adaptiveInitialized) {
 if (this.options.debug) console.log('📡 Adaptive streaming initialized');
 return;
 }
 }

 if (this.originalSrc) {
 this.video.src = this.originalSrc;
 }

 this.originalSources.forEach(sourceData => {
 if (sourceData.element && sourceData.src) {
 sourceData.element.src = sourceData.src;
 }
 });

 this.qualities = this.originalSources.map(s => ({
 src: s.src,
 quality: s.quality,
 type: s.type
 }));

 if (this.originalSrc && this.qualities.length === 0) {
 this.qualities.push({
 src: this.originalSrc,
 quality: 'default',
 type: 'video/mp4'
 });
 }

 if (this.qualities.length > 0) {
 this.video.load();

 this.video.addEventListener('loadedmetadata', () => {
 setTimeout(() => {
 this.reinitializeSubtitles();
 if (this.options.debug) console.log('🔄 Subtitles re-initialized after video load');
 }, 300);
 }, { once: true });
 }

 if (this.options.debug) console.log('✅ Sources ripristinate:', this.qualities);

 } catch (error) {
 if (this.options.debug) console.error('❌ Errore ripristino sources:', error);
 }
}

reinitializeSubtitles() {
 if (this.options.debug) console.log('🔄 Re-initializing subtitles...');

 this.textTracks = [];
 this.currentSubtitleTrack = null;
 this.subtitlesEnabled = false;

 this.detectTextTracks();
 this.updateSubtitlesUI();
 this.bindSubtitleEvents();

 if (this.options.debug) console.log(`📝 Re-detected ${this.textTracks.length} subtitle tracks`);

 const defaultTrack = this.getDefaultSubtitleTrack();
 if (defaultTrack !== -1 && this.options.subtitlesEnabled === true) { // <-- AGGIUNTO!
 setTimeout(() => {
 this.enableSubtitleTrack(defaultTrack);
 if (this.options.debug) console.log(`🎯 Auto-enabled default subtitle track: ${defaultTrack}`);
 }, 100);
 } else {
 if (this.options.debug) {
 console.log(`📝 Default subtitle track NOT auto-enabled:`, {
 defaultTrack: defaultTrack,
 subtitlesEnabled: this.options.subtitlesEnabled
 });
 }
 }
}

getDefaultSubtitleTrack() {
 if (!this.video.textTracks) return -1;

 for (let i = 0; i < this.video.textTracks.length; i++) {
 const track = this.video.textTracks[i];
 if (track.mode === 'showing' || track.default) {
 return i;
 }
 }
 return -1;
}

markPlayerReady() {
 setTimeout(() => {
 this.isPlayerReady = true;
 if (this.container) {
 this.container.classList.add('player-initialized');
 }

 this.triggerEvent('playerready', {
 playerState: this.getPlayerState(),
 qualities: this.qualities,
 subtitles: this.textTracks,
 chapters: this.chapters,
 playlist: this.getPlaylistInfo()
 });

 if (this.video) {
 this.video.style.visibility = '';
 this.video.style.opacity = '';
 this.video.style.pointerEvents = '';
 }

 setTimeout(() => {
 if (this.options.autoHide && !this.autoHideInitialized) {
 this.initAutoHide();
 }

 if (this.selectedQuality && this.qualities && this.qualities.length > 0) {
 if (this.options.debug) console.log(`🎯 Applying defaultQuality: "${this.selectedQuality}"`);

 if (this.selectedQuality === 'auto') {
 this.enableAutoQuality();
 } else {

 const requestedQuality = this.qualities.find(q => q.quality === this.selectedQuality);
 if (requestedQuality) {
 if (this.options.debug) console.log(`✅ Quality "${this.selectedQuality}" available`);
 this.setQuality(this.selectedQuality);
 } else {
 if (this.options.debug) console.warn(`⚠️ Quality "${this.selectedQuality}" not available - fallback to auto`);
 if (this.options.debug) console.log('📋 Available qualities:', this.qualities.map(q => q.quality));
 this.enableAutoQuality();
 }
 }
 }

 if (this.options.autoplay) {
 if (this.options.debug) console.log('🎬 Autoplay enabled');
 setTimeout(() => {
 this.video.play().catch(error => {
 if (this.options.debug) console.warn('⚠️ Autoplay blocked:', error);
 });
 }, 100);
 }
 }, 200);

 }, 100);
}

createPlayerStructure() {
 let wrapper = this.video.closest('.video-wrapper');
 if (!wrapper) {
 wrapper = document.createElement('div');
 wrapper.className = 'video-wrapper';
 this.video.parentNode.insertBefore(wrapper, this.video);
 wrapper.appendChild(this.video);
 }

 this.container = wrapper;

 this.createInitialLoading();
 this.createLoadingOverlay();
 this.collectVideoQualities();
 this.createControls();
 this.createBrandLogo();
 this.detectPlaylist();

 if (this.options.showTitleOverlay) {
 this.createTitleOverlay();
 }
}

createInitialLoading() {
 const initialLoader = document.createElement('div');
 initialLoader.className = 'initial-loading';
 initialLoader.innerHTML = '<div class="loading-spinner"></div>';
 this.container.appendChild(initialLoader);
 this.initialLoading = initialLoader;
}

collectVideoQualities() {
 if (this.options.debug) console.log('📁 Video qualities will be loaded with restored sources');
}

createLoadingOverlay() {
 const overlay = document.createElement('div');
 overlay.className = 'loading-overlay';
 overlay.id = 'loadingOverlay-' + this.getUniqueId();
 overlay.innerHTML = '<div class="loading-spinner"></div>';
 this.container.appendChild(overlay);
 this.loadingOverlay = overlay;
}

createTitleOverlay() {
 const overlay = document.createElement('div');
 overlay.className = 'title-overlay';
 overlay.id = 'titleOverlay-' + this.getUniqueId();

 const titleText = document.createElement('h2');
 titleText.className = 'title-text';
 titleText.textContent = this.options.videoTitle || '';
 overlay.appendChild(titleText);

 if (this.options.videoSubtitle) {
 const subtitleText = document.createElement('p');
 subtitleText.className = 'subtitle-text';
 subtitleText.textContent = this.options.videoSubtitle;
 overlay.appendChild(subtitleText);
 }

 if (this.controls) {
 this.container.insertBefore(overlay, this.controls);
 } else {
 this.container.appendChild(overlay);
 }

 this.titleOverlay = overlay;

 if (this.options.persistentTitle && this.options.videoTitle) {
 this.showTitleOverlay();
 }
}

updateTooltips() {
 if (!this.controls) return;

 try {
 this.controls.querySelectorAll('[data-tooltip]').forEach(element => {
 const key = element.getAttribute('data-tooltip');
 element.title = this.t(key);
 });

 const autoOption = this.controls.querySelector('.quality-option[data-quality="auto"]');
 if (autoOption) {
 autoOption.textContent = this.t('auto');
 }
 } catch (error) {
 if (this.options.debug) console.warn('Errore aggiornamento tooltip:', error);
 }
}

setLanguage(lang) {
 if (this.isI18nAvailable()) {
 try {
 if (VideoPlayerTranslations.setLanguage(lang)) {
 this.updateTooltips();
 return true;
 }
 } catch (error) {
 if (this.options.debug) console.warn('Errore cambio lingua:', error);
 }
 }
 return false;
}

setVideoTitle(title) {
 this.options.videoTitle = title || '';

 if (this.titleOverlay) {
 const titleElement = this.titleOverlay.querySelector('.title-text');
 if (titleElement) {
 titleElement.textContent = this.options.videoTitle;
 }

 if (title) {
 this.showTitleOverlay();

 if (!this.options.persistentTitle) {
 this.clearTitleTimeout();
 this.titleTimeout = setTimeout(() => {
 this.hideTitleOverlay();
 }, 3000);
 }
 }
 }

 return this;
}

getVideoTitle() {
 return this.options.videoTitle;
}

setVideoSubtitle(subtitle) {
 this.options.videoSubtitle = subtitle || '';

 if (this.titleOverlay) {
 let subtitleElement = this.titleOverlay.querySelector('.subtitle-text');

 if (subtitle) {
 if (!subtitleElement) {
 subtitleElement = document.createElement('p');
 subtitleElement.className = 'subtitle-text';
 this.titleOverlay.appendChild(subtitleElement);
 }
 subtitleElement.textContent = subtitle;
 } else if (subtitleElement) {
 subtitleElement.remove();
 }
 }

 return this;
}

getVideoSubtitle() {
 return this.options.videoSubtitle;
}

setPersistentTitle(persistent) {
 this.options.persistentTitle = persistent;

 if (this.titleOverlay && this.options.videoTitle) {
 if (persistent) {
 this.showTitleOverlay();
 this.clearTitleTimeout();
 } else {
 this.titleOverlay.classList.remove('persistent');
 if (this.titleOverlay.classList.contains('show')) {
 this.clearTitleTimeout();
 this.titleTimeout = setTimeout(() => {
 this.hideTitleOverlay();
 }, 3000);
 }
 }
 }

 return this;
}

enableTitleOverlay() {
 if (!this.titleOverlay && !this.options.showTitleOverlay) {
 this.options.showTitleOverlay = true;
 this.createTitleOverlay();
 }
 return this;
}

disableTitleOverlay() {
 if (this.titleOverlay) {
 this.titleOverlay.remove();
 this.titleOverlay = null;
 }
 this.options.showTitleOverlay = false;
 return this;
}

getUniqueId() {
 return Math.random().toString(36).substr(2, 9);
}

initializeElements() {
 this.progressContainer = this.controls?.querySelector('.progress-container');
 this.progressFilled = this.controls?.querySelector('.progress-filled');
 this.progressBuffer = this.controls?.querySelector('.progress-buffer');
 this.progressHandle = this.controls?.querySelector('.progress-handle');
 this.seekTooltip = this.controls?.querySelector('.seek-tooltip');

 this.playPauseBtn = this.controls?.querySelector('.play-pause-btn');
 this.muteBtn = this.controls?.querySelector('.mute-btn');
 this.fullscreenBtn = this.controls?.querySelector('.fullscreen-btn');
 this.speedBtn = this.controls?.querySelector('.speed-btn');
 this.qualityBtn = this.controls?.querySelector('.quality-btn');
 this.pipBtn = this.controls?.querySelector('.pip-btn');
 this.subtitlesBtn = this.controls?.querySelector('.subtitles-btn');
 this.playlistPrevBtn = this.controls?.querySelector('.playlist-prev-btn');
 this.playlistNextBtn = this.controls?.querySelector('.playlist-next-btn');

 this.playIcon = this.controls?.querySelector('.play-icon');
 this.pauseIcon = this.controls?.querySelector('.pause-icon');
 this.volumeIcon = this.controls?.querySelector('.volume-icon');
 this.muteIcon = this.controls?.querySelector('.mute-icon');
 this.fullscreenIcon = this.controls?.querySelector('.fullscreen-icon');
 this.exitFullscreenIcon = this.controls?.querySelector('.exit-fullscreen-icon');
 this.pipIcon = this.controls?.querySelector('.pip-icon');
 this.pipExitIcon = this.controls?.querySelector('.pip-exit-icon');

 this.volumeSlider = this.controls?.querySelector('.volume-slider');
 this.currentTimeEl = this.controls?.querySelector('.current-time');
 this.durationEl = this.controls?.querySelector('.duration');
 this.speedMenu = this.controls?.querySelector('.speed-menu');
 this.qualityMenu = this.controls?.querySelector('.quality-menu');
 this.subtitlesMenu = this.controls?.querySelector('.subtitles-menu');

 if (this.progressHandle && this.options.seekHandleShape) {
 this.setSeekHandleShape(this.options.seekHandleShape);
 }
}

closeAllMenus() {
 if (!this.controls) return;

 const menus = this.controls.querySelectorAll('.speed-menu, .quality-menu, .subtitles-menu, .settings-menu');
 const buttons = this.controls.querySelectorAll('.control-btn');

 menus.forEach(menu => menu.classList.remove('active'));
 buttons.forEach(btn => btn.classList.remove('active'));

 this.currentOpenMenu = null;

 if (this.options.debug) {
 console.log('All menus closed');
 }
}

setupMenuToggles() {
 if (!this.controls) return;

 this.currentOpenMenu = null;

 this.controls.addEventListener('click', (e) => {
 const button = e.target.closest('.control-btn');
 if (!button) return;

 const buttonClasses = Array.from(button.classList);
 let menuElement = null;

 for (const cls of buttonClasses) {
 if (cls.endsWith('-btn')) {
 const menuClass = cls.replace('-btn', '-menu');
 menuElement = this.controls.querySelector(`.${menuClass}`);
 if (menuElement) break;
 }
 }

 if (!menuElement) return;

 e.stopPropagation();
 e.preventDefault();

 const isOpen = menuElement.classList.contains('active');

 this.closeAllMenus();

 if (!isOpen) {
 menuElement.classList.add('active');
 button.classList.add('active');
 this.currentOpenMenu = menuElement;
 if (this.options.debug) {
 console.log('Menu opened:', menuElement.className);
 }
 } else {
 this.currentOpenMenu = null;
 if (this.options.debug) {
 console.log('Menu closed:', menuElement.className);
 }
 }
 });

 document.addEventListener('click', (e) => {
 if (!this.controls) return;
 if (!this.controls.contains(e.target)) {
 this.closeAllMenus();
 }
 });

 if (this.options.debug) {
 console.log('✅ Menu toggle system initialized (click-based, auto-close)');
 }
}

updateVolumeSliderVisual() {
 if (!this.video || !this.container) return;

 const volume = this.video.muted ? 0 : this.video.volume;
 const percentage = Math.round(volume * 100);

 this.container.style.setProperty('--player-volume-fill', percentage + '%');

 if (this.volumeSlider) {
 this.volumeSlider.value = percentage;
 }
}

createVolumeTooltip() {
 const volumeContainer = this.controls?.querySelector('.volume-container');
 if (!volumeContainer || volumeContainer.querySelector('.volume-tooltip')) {
 return; // Tooltip already present
 }

 const tooltip = document.createElement('div');
 tooltip.className = 'volume-tooltip';
 tooltip.textContent = '50%';
 volumeContainer.appendChild(tooltip);

 this.volumeTooltip = tooltip;

 if (this.options.debug) {
 console.log('Dynamic volume tooltip created');
 }
}

updateVolumeTooltip() {
 if (!this.volumeTooltip || !this.video) return;

 const volume = Math.round(this.video.volume * 100);
 this.volumeTooltip.textContent = volume + '%';

 this.updateVolumeTooltipPosition(this.video.volume);

 if (this.options.debug) {
 console.log('Volume tooltip updated:', volume + '%');
 }
}

updateVolumeTooltipPosition(volumeValue = null) {
 if (!this.volumeTooltip || !this.video) return;

 const volumeSlider = this.controls?.querySelector('.volume-slider');
 if (!volumeSlider) return;

 if (volumeValue === null) {
 volumeValue = this.video.volume;
 }

 const sliderRect = volumeSlider.getBoundingClientRect();
 const sliderWidth = sliderRect.width;

 const thumbSize = 14; // var(--player-volume-handle-size)

 const availableWidth = sliderWidth - thumbSize;
 const thumbCenterPosition = (thumbSize / 2) + (availableWidth * volumeValue);

 const percentage = (thumbCenterPosition / sliderWidth) * 100;

 this.volumeTooltip.style.left = percentage + '%';

 if (this.options.debug) {
 console.log('Volume tooltip position updated:', {
 volumeValue: volumeValue,
 percentage: percentage + '%',
 thumbCenter: thumbCenterPosition,
 sliderWidth: sliderWidth
 });
 }
}

initVolumeTooltip() {
 this.createVolumeTooltip();

 setTimeout(() => {
 if (this.volumeTooltip && this.video) {
 this.updateVolumeTooltipPosition(this.video.volume);
 this.updateVolumeTooltip();
 }
 }, 50); // Shorter delay for faster initialization
}

updateVolumeSliderVisualWithTooltip() {
 const volumeSlider = this.controls?.querySelector('.volume-slider');
 if (!volumeSlider || !this.video) return;

 const volume = this.video.volume || 0;
 const percentage = Math.round(volume * 100);

 volumeSlider.value = volume;

 const volumeFillPercentage = percentage + '%';
 volumeSlider.style.setProperty('--player-volume-fill', volumeFillPercentage);

 this.updateVolumeTooltip();

 if (this.options.debug) {
 console.log('Volume slider aggiornato:', {
 volume: volume,
 percentage: percentage,
 fillPercentage: volumeFillPercentage
 });
 }
}

setMobileVolumeSlider(mode) {
 if (!['show', 'hide'].includes(mode)) {
 if (this.options.debug) console.warn('Invalid mobile volume slider mode:', mode);
 return this;
 }

 this.options.mobileVolumeSlider = mode;
 const volumeContainer = this.controls?.querySelector('.volume-container');
 if (volumeContainer) {

 volumeContainer.setAttribute('data-mobile-slider', mode);
 if (this.options.debug) console.log('Mobile volume slider set to:', mode);
 }
 return this;
}

getMobileVolumeSlider() {
 return this.options.mobileVolumeSlider;
}

initVolumeTooltip() {

 this.createVolumeTooltip();

 setTimeout(() => {
 this.updateVolumeTooltip();
 }, 200);

 if (this.options.debug) {
 console.log('Dynamic volume tooltip inizializzation');
 }
}

setupSeekTooltip() {
 if (!this.options.showSeekTooltip || !this.progressContainer || !this.seekTooltip) return;

 this.progressContainer.addEventListener('mouseenter', () => {
 if (this.seekTooltip) {
 this.seekTooltip.classList.add('visible');
 }
 });

 this.progressContainer.addEventListener('mouseleave', () => {
 if (this.seekTooltip) {
 this.seekTooltip.classList.remove('visible');
 }
 });

 this.progressContainer.addEventListener('mousemove', (e) => {
 this.updateSeekTooltip(e);
 });
}

updateSeekTooltip(e) {
 if (!this.seekTooltip || !this.progressContainer || !this.video || !this.video.duration) return;

 const rect = this.progressContainer.getBoundingClientRect();
 const clickX = e.clientX - rect.left;
 const percentage = Math.max(0, Math.min(1, clickX / rect.width));
 const targetTime = percentage * this.video.duration;

 this.seekTooltip.textContent = this.formatTime(targetTime);

 const tooltipRect = this.seekTooltip.getBoundingClientRect();
 let leftPosition = clickX;

 const tooltipWidth = tooltipRect.width || 50;
 const containerWidth = rect.width;

 leftPosition = Math.max(tooltipWidth / 2, Math.min(containerWidth - tooltipWidth / 2, clickX));

 this.seekTooltip.style.left = leftPosition + 'px';
}

play() {
 if (!this.video || this.isChangingQuality) return;

 this.video.play().catch(err => {
 if (this.options.debug) console.log('Play failed:', err);
 });

 if (this.playIcon) this.playIcon.classList.add('hidden');
 if (this.pauseIcon) this.pauseIcon.classList.remove('hidden');

 this.triggerEvent('played', {
 currentTime: this.getCurrentTime(),
 duration: this.getDuration()
 });
}

pause() {
 if (!this.video) return;

 this.video.pause();
 if (this.playIcon) this.playIcon.classList.remove('hidden');
 if (this.pauseIcon) this.pauseIcon.classList.add('hidden');

 this.triggerEvent('paused', {
 currentTime: this.getCurrentTime(),
 duration: this.getDuration()
 });
}

updateVolume(value) {
 if (!this.video) return;

 const previousVolume = this.video.volume;
 const previousMuted = this.video.muted;

 this.video.volume = Math.max(0, Math.min(1, value / 100));

 if (this.video.volume > 0 && this.video.muted) {
 this.video.muted = false;
 }

 if (this.volumeSlider) this.volumeSlider.value = value;
 this.updateMuteButton();
 this.updateVolumeSliderVisual();
 this.initVolumeTooltip();

 if (Math.abs(previousVolume - this.video.volume) > 0.01 || previousMuted !== this.video.muted) {
 this.triggerEvent('volumechange', {
 volume: this.getVolume(),
 muted: this.isMuted(),
 previousVolume: previousVolume,
 previousMuted: previousMuted
 });
 }
}

changeVolume(delta) {
 if (!this.video) return;

 const newVolume = Math.max(0, Math.min(1, this.video.volume + delta));
 this.updateVolume(newVolume * 100);
 this.updateVolumeSliderVisual();
 this.initVolumeTooltip();
}

updateProgress() {
 if (!this.video || !this.progressFilled || !this.progressHandle || this.isUserSeeking) return;

 if (this.video.duration && !isNaN(this.video.duration)) {
 const progress = (this.video.currentTime / this.video.duration) * 100;
 this.progressFilled.style.width = progress + '%';
 this.progressHandle.style.left = progress + '%';
 }

 this.updateTimeDisplay();

 if (!this.lastTimeUpdate || Date.now() - this.lastTimeUpdate > 250) {
 this.triggerEvent('timeupdate', {
 currentTime: this.getCurrentTime(),
 duration: this.getDuration(),
 progress: (this.getCurrentTime() / this.getDuration()) * 100 || 0
 });
 this.lastTimeUpdate = Date.now();
 }
}

updateBuffer() {
 if (!this.video || !this.progressBuffer) return;

 try {
 if (this.video.buffered && this.video.buffered.length > 0 && this.video.duration) {
 const buffered = (this.video.buffered.end(0) / this.video.duration) * 100;
 this.progressBuffer.style.width = buffered + '%';
 }
 } catch (error) {
 if (this.options.debug) console.log('Buffer update error (non-critical):', error);
 }
}

startSeeking(e) {
 if (e.cancelable) e.preventDefault();
 if (this.isChangingQuality) return;

 this.isUserSeeking = true;
 this.progressContainer.classList.add('seeking');
 this.seek(e);
 e.preventDefault();

 if (this.options.autoHide && this.autoHideInitialized) {
 this.showControlsNow();
 this.resetAutoHideTimer();
 }
}

continueSeeking(e) {
 if (e.cancelable) e.preventDefault();
 if (this.isUserSeeking && !this.isChangingQuality) {
 this.seek(e);
 }
}

endSeeking() {
 this.isUserSeeking = false;
 this.progressContainer.classList.remove('seeking');
}

seek(e) {
 if (e.cancelable) {
 e.preventDefault();
 }
 if (!this.video || !this.progressContainer || !this.progressFilled || !this.progressHandle || this.isChangingQuality) return;

 const rect = this.progressContainer.getBoundingClientRect();

 const clientX = e.clientX !== undefined ? e.clientX : (e.touches && e.touches[0] ? e.touches[0].clientX : (e.changedTouches && e.changedTouches[0] ? e.changedTouches[0].clientX : 0));

 const clickX = clientX - rect.left;
 const percentage = Math.max(0, Math.min(1, clickX / rect.width));

 if (this.video.duration && !isNaN(this.video.duration)) {
 this.video.currentTime = percentage * this.video.duration;

 const progress = `${percentage * 100}%`;
 this.progressFilled.style.width = progress;
 this.progressHandle.style.left = progress;
 }
}

updateDuration() {
 if (this.durationEl && this.video && this.video.duration && !isNaN(this.video.duration)) {
 this.durationEl.textContent = this.formatTime(this.video.duration);
 }
}

changeSpeed(e) {
 if (!this.video || !e.target.classList.contains('speed-option') || this.isChangingQuality) return;

 const speed = parseFloat(e.target.getAttribute('data-speed'));
 if (speed && speed > 0) {
 this.video.playbackRate = speed;
 if (this.speedBtn) this.speedBtn.textContent = speed + 'x';

 if (this.speedMenu) {
 this.speedMenu.querySelectorAll('.speed-option').forEach(option => {
 option.classList.remove('active');
 });
 e.target.classList.add('active');
 }

 const previousSpeed = this.video.playbackRate;
 this.triggerEvent('speedchange', {
 speed: speed,
 previousSpeed: previousSpeed
 });
 }
}

onVideoEnded() {
 if (this.playIcon) this.playIcon.classList.remove('hidden');
 if (this.pauseIcon) this.pauseIcon.classList.add('hidden');

 if (this.options.loop) {
 if (this.options.debug) console.log('🔄 Video loop enabled - restarting from beginning');
 this.video.currentTime = 0;
 this.video.play().catch(error => {
 if (this.options.debug) console.warn('Loop play failed:', error);
 });
 return; // Don't show controls or trigger ended event when looping
 }

 this.showControlsNow();

 this.triggerEvent('ended', {
 currentTime: this.getCurrentTime(),
 duration: this.getDuration(),
 playlistInfo: this.getPlaylistInfo()
 });
}

onVideoError(error) {
 if (this.options.debug) {
 console.error('Video loading error detected:', {
 error: error,
 code: this.video?.error?.code,
 message: this.video?.error?.message,
 src: this.video?.currentSrc || this.video?.src
 });
 }

 this.hideLoading();
 if (this.initialLoading) {
 this.initialLoading.style.display = 'none';
 }

 if (this.video?.classList) {
 this.video.classList.remove('quality-changing');
 }

 this.isChangingQuality = false;

 this.showControlsNow();

 if (this.options.showPosterOnEnd && this.posterOverlay) {
 this.showPoster();
 }

 this.triggerEvent('ended', {
 currentTime: this.getCurrentTime(),
 duration: this.getDuration(),
 error: true,
 errorCode: this.video?.error?.code,
 errorMessage: this.video?.error?.message,
 playlistInfo: this.getPlaylistInfo()
 });

 if (this.options.debug) {
 console.log('Video error handled - triggered ended event');
 }
}

getCurrentTime() { return this.video ? this.video.currentTime || 0 : 0; }

setCurrentTime(time) { if (this.video && typeof time === 'number' && time >= 0 && !this.isChangingQuality) { this.video.currentTime = time; } }

getDuration() { return this.video && this.video.duration ? this.video.duration : 0; }

getVolume() { return this.video ? this.video.volume || 0 : 0; }

setVolume(volume) {
 if (typeof volume === 'number' && volume >= 0 && volume <= 1) {
 this.updateVolume(volume * 100);
 }
}

isPaused() { return this.video ? this.video.paused : true; }

isMuted() { return this.video ? this.video.muted : false; }

setMuted(muted) {
 if (this.video && typeof muted === 'boolean') {
 this.video.muted = muted;
 this.updateMuteButton();
 this.updateVolumeSliderVisual();
 this.initVolumeTooltip();
 }
}

getPlaybackRate() { return this.video ? this.video.playbackRate || 1 : 1; }

setPlaybackRate(rate) { if (this.video && typeof rate === 'number' && rate > 0 && !this.isChangingQuality) { this.video.playbackRate = rate; if (this.speedBtn) this.speedBtn.textContent = rate + 'x'; } }

isPictureInPictureActive() { return document.pictureInPictureElement === this.video; }

getCurrentLanguage() {
 return this.isI18nAvailable() ?
 VideoPlayerTranslations.getCurrentLanguage() : 'en';
}

getSupportedLanguages() {
 return this.isI18nAvailable() ?
 VideoPlayerTranslations.getSupportedLanguages() : ['en'];
}

createBrandLogo() {
 if (!this.options.brandLogoEnabled || !this.options.brandLogoUrl) return;

 const controlsRight = this.controls?.querySelector('.controls-right');
 if (!controlsRight) return;

 const logo = document.createElement('img');
 logo.className = 'brand-logo';
 logo.src = this.options.brandLogoUrl;
 logo.alt = 'Brand logo';

 if (this.options.brandLogoLinkUrl) {

 logo.title = this.options.brandLogoTooltipText || this.options.brandLogoLinkUrl;

 }

 logo.onerror = () => {
 if (this.options.debug) console.warn('Brand logo failed to load:', this.options.brandLogoUrl);
 logo.style.display = 'none';
 };

 logo.onload = () => {
 if (this.options.debug) console.log('Brand logo loaded successfully');
 };

 if (this.options.brandLogoLinkUrl) {
 logo.style.cursor = 'pointer';
 logo.addEventListener('click', (e) => {
 e.stopPropagation();
 window.open(this.options.brandLogoLinkUrl, '_blank', 'noopener,noreferrer');
 if (this.options.debug) console.log('Brand logo clicked, opening:', this.options.brandLogoLinkUrl);
 });
 } else {
 logo.style.cursor = 'default';
 }

 controlsRight.insertBefore(logo, controlsRight.firstChild);

 if (this.options.debug) {
 console.log('Brand logo created with tooltip:', logo.title || 'no tooltip');
 }
}

setBrandLogo(enabled, url = '', linkUrl = '') {
 this.options.brandLogoEnabled = enabled;
 if (url) {
 this.options.brandLogoUrl = url;
 }
 if (linkUrl !== '') {
 this.options.brandLogoLinkUrl = linkUrl;
 }

 const existingLogo = this.controls?.querySelector('.brand-logo');
 if (existingLogo) {
 existingLogo.remove();
 }

 if (enabled && this.options.brandLogoUrl) {
 this.createBrandLogo();
 }

 return this;
}

getBrandLogoSettings() {
 return {
 enabled: this.options.brandLogoEnabled,
 url: this.options.brandLogoUrl,
 linkUrl: this.options.brandLogoLinkUrl
 };
}

switchToVideo(newVideoElement, shouldPlay = false) {
 if (!newVideoElement) {
 if (this.options.debug) console.error('🎵 New video element not found');
 return false;
 }

 this.video.pause();

 const newSources = Array.from(newVideoElement.querySelectorAll('source')).map(source => ({
 src: source.src,
 quality: source.getAttribute('data-quality') || 'auto',
 type: source.type || 'video/mp4'
 }));

 if (newSources.length === 0) {
 if (this.options.debug) console.error('🎵 New video has no sources');
 return false;
 }

 if (this.options.adaptiveStreaming && newSources.length > 0) {
 const firstSource = newSources[0];
 if (this.detectStreamType(firstSource.src)) {

 this.initializeAdaptiveStreaming(firstSource.src).then((initialized) => {
 if (initialized && shouldPlay) {
 const playPromise = this.video.play();
 if (playPromise) {
 playPromise.catch(error => {
 if (this.options.debug) console.log('Autoplay prevented:', error);
 });
 }
 }
 });
 return true;
 }
 }

 this.video.innerHTML = '';
 newSources.forEach(source => {
 const sourceEl = document.createElement('source');
 sourceEl.src = source.src;
 sourceEl.type = source.type;
 sourceEl.setAttribute('data-quality', source.quality);
 this.video.appendChild(sourceEl);
 });

 const newTracks = Array.from(newVideoElement.querySelectorAll('track'));
 newTracks.forEach(track => {
 const trackEl = document.createElement('track');
 trackEl.kind = track.kind;
 trackEl.src = track.src;
 trackEl.srclang = track.srclang;
 trackEl.label = track.label;
 if (track.default) trackEl.default = true;
 this.video.appendChild(trackEl);
 });

 const newTitle = newVideoElement.getAttribute('data-video-title');
 if (newTitle && this.options.showTitleOverlay) {
 this.options.videoTitle = newTitle;
 if (this.titleText) {
 this.titleText.textContent = newTitle;
 }
 }

 this.video.load();

 this.collectVideoQualities();
 this.updateQualityMenu();

 if (shouldPlay) {
 const playPromise = this.video.play();
 if (playPromise) {
 playPromise.catch(error => {
 if (this.options.debug) console.log('🎵 Autoplay prevented:', error);
 });
 }
 }

 return true;
}

initializePoster() {
 if (!this.video) {
 return;
 }

 if (this.options.poster) {
 this.video.setAttribute('poster', this.options.poster);
 if (this.options.debug) console.log('🖼️ Poster set from options:', this.options.poster);
 }

 this.createPosterOverlay();

 this.bindPosterEvents();

 if (this.options.debug) console.log('🖼️ Poster management initialized');
}

createPosterOverlay() {
 if (!this.container || !this.video) {
 return;
 }

 const posterUrl = this.video.getAttribute('poster') || this.options.poster;

 if (!posterUrl) {
 if (this.options.debug) console.log('🖼️ No poster URL found');
 return;
 }

 const posterOverlay = document.createElement('div');
 posterOverlay.className = 'video-poster-overlay';
 posterOverlay.style.backgroundImage = `url(${posterUrl})`;

 if (this.controls) {
 this.container.insertBefore(posterOverlay, this.controls);
 } else {
 this.container.appendChild(posterOverlay);
 }

 this.posterOverlay = posterOverlay;

 if (this.options.debug) console.log('🖼️ Custom poster overlay created');
}

bindPosterEvents() {
 if (!this.video || !this.posterOverlay) {
 return;
 }

 this.video.addEventListener('play', () => {
 this.hidePoster();
 });

 this.video.addEventListener('ended', () => {
 if (this.options.showPosterOnEnd) {
 this.showPoster();
 }
 });

 this.video.addEventListener('playing', () => {
 this.hidePoster();
 });

 if (!this.options.autoplay) {
 this.showPoster();
 }

 if (this.posterOverlay) {
 this.posterOverlay.addEventListener('click', (e) => {
 e.stopPropagation();
 if (this.video.paused) {
 this.play();
 }
 });
 }

 if (this.options.debug) console.log('🖼️ Poster events bound');
}

showPoster() {
 if (this.posterOverlay) {
 this.posterOverlay.classList.add('visible');
 this.posterOverlay.classList.remove('hidden');
 if (this.options.debug) console.log('🖼️ Poster shown');
 }
}

hidePoster() {
 if (this.posterOverlay) {
 this.posterOverlay.classList.remove('visible');
 this.posterOverlay.classList.add('hidden');
 if (this.options.debug) console.log('🖼️ Poster hidden');
 }
}

setPoster(posterUrl) {
 if (!posterUrl) {
 if (this.options.debug) console.warn('🖼️ Invalid poster URL');
 return this;
 }

 this.options.poster = posterUrl;

 if (this.video) {
 this.video.setAttribute('poster', posterUrl);
 }

 if (this.posterOverlay) {
 this.posterOverlay.style.backgroundImage = `url(${posterUrl})`;
 } else {
 this.createPosterOverlay();
 this.bindPosterEvents();
 }

 if (this.options.debug) console.log('🖼️ Poster updated:', posterUrl);

 return this;
}

getPoster() {
 return this.options.poster || this.video?.getAttribute('poster') || null;
}

removePoster() {
 if (this.posterOverlay) {
 this.posterOverlay.remove();
 this.posterOverlay = null;
 }

 if (this.video) {
 this.video.removeAttribute('poster');
 }

 this.options.poster = null;

 if (this.options.debug) console.log('🖼️ Poster removed');

 return this;
}

togglePoster(show = null) {
 if (!this.posterOverlay) {
 return this;
 }

 if (show === null) {

 if (this.posterOverlay.classList.contains('visible')) {
 this.hidePoster();
 } else {
 this.showPoster();
 }
 } else if (show) {
 this.showPoster();
 } else {
 this.hidePoster();
 }

 return this;
}

isPosterVisible() {
 return this.posterOverlay ? this.posterOverlay.classList.contains('visible') : false;
}

loadScript(src) {
 return new Promise((resolve, reject) => {
 if (document.querySelector(`script[src="${src}"]`)) {
 resolve();
 return;
 }

 const script = document.createElement('script');
 script.src = src;
 script.onload = resolve;
 script.onerror = reject;
 document.head.appendChild(script);
 });
}

setSeekHandleShape(shape) {
 const validShapes = ['none', 'circle', 'square', 'diamond', 'arrow', 'triangle', 'heart', 'star'];

 if (!validShapes.includes(shape)) {
 if (this.options.debug) console.warn('Invalid seek handle shape:', shape);
 return this;
 }

 this.options.seekHandleShape = shape;

 if (this.progressHandle) {

 validShapes.forEach(s => {
 this.progressHandle.classList.remove(`progress-handle-${s}`);
 });

 this.progressHandle.classList.add(`progress-handle-${shape}`);
 }

 if (this.options.debug) console.log('Seek handle shape changed to:', shape);
 return this;
}

getSeekHandleShape() {
 return this.options.seekHandleShape;
}

getAvailableSeekHandleShapes() {
 return ['none', 'circle', 'square', 'diamond', 'arrow', 'triangle', 'heart', 'star'];
}

dispose() {
 if (this.qualityMonitorInterval) {
 clearInterval(this.qualityMonitorInterval);
 this.qualityMonitorInterval = null;
 }

 if (this.autoHideTimer) {
 clearTimeout(this.autoHideTimer);
 this.autoHideTimer = null;
 }

 this.cleanupQualityChange();
 this.clearControlsTimeout();
 this.clearTitleTimeout();

 this.destroyAdaptivePlayer();

 if (this.controls) {
 this.controls.remove();
 }
 if (this.loadingOverlay) {
 this.loadingOverlay.remove();
 }
 if (this.titleOverlay) {
 this.titleOverlay.remove();
 }
 if (this.initialLoading) {
 this.initialLoading.remove();
 }

 if (this.video) {
 this.video.classList.remove('video-player');
 this.video.controls = true;
 this.video.style.visibility = '';
 this.video.style.opacity = '';
 this.video.style.pointerEvents = '';
 }
 if (this.chapterMarkersContainer) {
 this.chapterMarkersContainer.remove();
 }
 if (this.chapterTooltip) {
 this.chapterTooltip.remove();
 }
 if (this.posterOverlay) {
 this.posterOverlay.remove();
 }
 this.disposeAllPlugins();

}

addEventListener(eventType, callback) {
 if (typeof callback !== 'function') {
 if (this.options.debug) console.warn(`Callback for event '${eventType}' is not a function`);
 return this;
 }

 if (!this.eventCallbacks[eventType]) {
 this.eventCallbacks[eventType] = [];
 }

 this.eventCallbacks[eventType].push(callback);
 if (this.options.debug) console.log(`Event '${eventType}' registered`);
 return this;
 }

 removeEventListener(eventType, callback) {
 if (!this.eventCallbacks[eventType]) return this;

 const index = this.eventCallbacks[eventType].indexOf(callback);
 if (index > -1) {
 this.eventCallbacks[eventType].splice(index, 1);
 if (this.options.debug) console.log(`Event '${eventType}' removed`);
 }
 return this;
 }

 triggerEvent(eventType, data = {}) {
 if (!this.eventCallbacks[eventType]) return;

 this.eventCallbacks[eventType].forEach(callback => {
 try {
 callback({
 type: eventType,
 timestamp: Date.now(),
 player: this,
 ...data
 });
 } catch (error) {
 if (this.options.debug) console.error(`Error in event '${eventType}':`, error);
 }
 });
 }

 getEventData() {
 const state = this.getPlayerState();
 return {
 played: state.isPlaying,
 paused: state.isPaused,
 subtitleEnabled: state.subtitlesEnabled,
 pipMode: state.isPictureInPicture,
 fullscreenMode: state.isFullscreen,
 speed: state.playbackRate,
 controlBarLength: state.currentTime,
 volumeIsMuted: state.isMuted,

 duration: state.duration,
 volume: state.volume,
 quality: state.currentQuality,
 buffered: this.getBufferedTime()
 };
 }

 bindSubtitleEvents() {
 if (this.video.textTracks) {
 for (let i = 0; i < this.video.textTracks.length; i++) {
 const track = this.video.textTracks[i];

 track.addEventListener('cuechange', () => {
 if (this.options.debug) console.log('Cue change detected:', track.activeCues);
 });
 }
 }
 }

 setupVolumeTooltipEvents() {
 const volumeSlider = this.controls?.querySelector('.volume-slider');
 if (!volumeSlider) return;

 let isMouseOverVolume = false;
 let isDragging = false;

 volumeSlider.addEventListener('mouseenter', () => {
 isMouseOverVolume = true;

 this.updateVolumeTooltipPosition(this.video.volume);
 this.updateVolumeTooltip();
 if (this.volumeTooltip) {
 this.volumeTooltip.classList.add('visible');
 }
 });

 volumeSlider.addEventListener('mouseleave', () => {
 isMouseOverVolume = false;
 if (!isDragging) {
 setTimeout(() => {
 if (!isMouseOverVolume && !isDragging && this.volumeTooltip) {
 this.volumeTooltip.classList.remove('visible');
 }
 }, 150);
 }
 });

 volumeSlider.addEventListener('mousemove', (e) => {
 if (isMouseOverVolume && this.volumeTooltip && !isDragging) {
 const rect = volumeSlider.getBoundingClientRect();
 const offsetX = e.clientX - rect.left;
 const sliderWidth = rect.width;

 const thumbSize = 14;
 const availableWidth = sliderWidth - thumbSize;
 let volumeAtPosition = (offsetX - thumbSize / 2) / availableWidth;
 volumeAtPosition = Math.max(0, Math.min(1, volumeAtPosition));

 const hoverVolume = Math.round(volumeAtPosition * 100);

 this.updateVolumeTooltipPosition(volumeAtPosition);
 this.volumeTooltip.textContent = hoverVolume + '%';
 }
 });

 volumeSlider.addEventListener('mousedown', () => {
 isDragging = true;
 if (this.volumeTooltip) {

 this.updateVolumeTooltipPosition(this.video.volume);
 this.volumeTooltip.classList.add('visible');
 }
 });

 document.addEventListener('mouseup', () => {
 if (isDragging) {
 isDragging = false;
 setTimeout(() => {
 if (!isMouseOverVolume && this.volumeTooltip) {
 this.volumeTooltip.classList.remove('visible');
 }
 }, 500);
 }
 });

 volumeSlider.addEventListener('input', (e) => {
 const volumeValue = parseFloat(e.target.value);
 const volume = Math.round(volumeValue * 100);
 if (this.volumeTooltip) {

 this.updateVolumeTooltipPosition(volumeValue);
 this.volumeTooltip.textContent = volume + '%';
 }
 isDragging = true;
 });

 volumeSlider.addEventListener('change', () => {

 this.updateVolumeTooltip();
 setTimeout(() => {
 isDragging = false;
 }, 100);
 });
 }

 bindEvents() {
 if (this.video) {

 this.video.addEventListener('playing', () => {
 this.hideLoading();
 this.closeAllMenus();

 this.triggerEvent('playing', {
 currentTime: this.getCurrentTime(),
 duration: this.getDuration()
 });
 });

 this.video.addEventListener('waiting', () => {
 if (!this.isChangingQuality) {
 this.showLoading();

 this.triggerEvent('waiting', {
 currentTime: this.getCurrentTime()
 });
 }
 });

 this.video.addEventListener('seeking', () => {

 this.triggerEvent('seeking', {
 currentTime: this.getCurrentTime(),
 targetTime: this.video.currentTime
 });
 });

 this.video.addEventListener('seeked', () => {

 this.triggerEvent('seeked', {
 currentTime: this.getCurrentTime()
 });
 });

 this.video.addEventListener('loadstart', () => {
 if (!this.isChangingQuality) {
 this.showLoading();
 }

 this.triggerEvent('loadstart');
 });

 this.video.addEventListener('loadedmetadata', () => {
 this.updateDuration();

 this.triggerEvent('loadedmetadata', {
 duration: this.getDuration(),
 videoWidth: this.video.videoWidth,
 videoHeight: this.video.videoHeight
 });

 setTimeout(() => {
 this.initializeSubtitles();
 }, 100);
 });

 this.video.addEventListener('loadeddata', () => {
 if (!this.isChangingQuality) {
 this.hideLoading();
 }

 this.triggerEvent('loadeddata', {
 currentTime: this.getCurrentTime()
 });
 });

 this.video.addEventListener('canplay', () => {
 if (!this.isChangingQuality) {
 this.hideLoading();
 }

 this.triggerEvent('canplay', {
 currentTime: this.getCurrentTime(),
 duration: this.getDuration()
 });
 });

 this.video.addEventListener('progress', () => {
 this.updateBuffer();

 this.triggerEvent('progress', {
 buffered: this.getBufferedTime(),
 duration: this.getDuration()
 });
 });

 this.video.addEventListener('durationchange', () => {
 this.updateDuration();

 this.triggerEvent('durationchange', {
 duration: this.getDuration()
 });
 });

 this.video.addEventListener('error', (e) => {
 this.onVideoError(e);

 this.triggerEvent('error', {
 code: this.video.error?.code,
 message: this.video.error?.message,
 src: this.video.currentSrc || this.video.src
 });
 });

 this.video.addEventListener('stalled', () => {

 this.triggerEvent('stalled', {
 currentTime: this.getCurrentTime()
 });
 });

 this.video.addEventListener('timeupdate', () => this.updateProgress());

 this.video.addEventListener('ended', () => this.onVideoEnded());

 this.video.addEventListener('click', () => {
 if (!this.options.pauseClick) return;

 if (this.options.doubleTapPause) {

 const controlsVisible = this.controls && this.controls.classList.contains('show');

 if (controlsVisible) {

 this.togglePlayPause();
 } else {

 this.showControlsNow();
 this.resetAutoHideTimer();
 }
 } else {

 this.togglePlayPause();
 }
 });
 this.video.addEventListener('volumechange', () => this.updateVolumeSliderVisual());

 this.video.addEventListener('touchend', (e) => {

 e.preventDefault();

 if (!this.options.pauseClick) return;

 if (this.options.doubleTapPause) {

 const controlsVisible = this.controls && this.controls.classList.contains('show');

 if (controlsVisible) {

 this.togglePlayPause();
 } else {

 this.showControlsNow();
 this.resetAutoHideTimer();
 }
 } else {

 this.togglePlayPause();
 }
 });

 this.video.addEventListener('play', () => {
 if (this.options.autoHide && this.autoHideInitialized) {
 this.showControlsNow();
 this.resetAutoHideTimer();
 }
 });

 this.video.addEventListener('enterpictureinpicture', () => {
 this.onEnterPiP();
 this.triggerEvent('pipchange', {
 active: true,
 mode: 'enter'
 });
 });

 this.video.addEventListener('leavepictureinpicture', () => {
 this.onLeavePiP();
 this.triggerEvent('pipchange', {
 active: false,
 mode: 'exit'
 });
 });
 }

 if (this.playPauseBtn) {
 this.playPauseBtn.addEventListener('click', () => this.togglePlayPause());
 }

 if (this.muteBtn) {
 this.muteBtn.addEventListener('click', () => this.toggleMute());
 }

 if (this.fullscreenBtn) {
 this.fullscreenBtn.addEventListener('click', () => this.toggleFullscreen());
 }

 if (this.pipBtn) {
 this.pipBtn.addEventListener('click', () => this.togglePictureInPicture());
 }

 if (this.volumeSlider) {
 this.volumeSlider.addEventListener('input', (e) => {
 this.updateVolume(e.target.value);
 this.updateVolumeSliderVisual();
 this.initVolumeTooltip();
 });
 }

 if (this.progressContainer) {

 this.progressContainer.addEventListener('click', (e) => this.seek(e));
 this.progressContainer.addEventListener('mousedown', (e) => this.startSeeking(e));
 if (this.progressHandle) {
 this.progressHandle.addEventListener('mousedown', this.startSeeking.bind(this));
 this.progressHandle.addEventListener('touchstart', this.startSeeking.bind(this), { passive: false });
 }

 this.progressContainer.addEventListener('touchstart', (e) => {
 e.preventDefault(); // Prevent scrolling when touching the seek bar
 this.startSeeking(e);
 }, { passive: false });

 this.setupSeekTooltip();
 }

 if (this.progressHandle) {
 this.progressHandle.addEventListener('touchstart', (e) => {
 e.preventDefault(); // Prevent default touch behavior
 e.stopPropagation(); // Stop event from bubbling to progressContainer
 this.startSeeking(e);
 }, { passive: false });
 }

 if (this.speedMenu) {
 this.speedMenu.addEventListener('click', (e) => this.changeSpeed(e));
 }

 if (this.qualityMenu) {
 this.qualityMenu.addEventListener('click', (e) => this.changeQuality(e));
 }

 if (this.subtitlesMenu) {
 this.subtitlesMenu.addEventListener('click', (e) => this.handleSubtitlesMenuClick(e));
 }

 document.addEventListener('fullscreenchange', () => this.updateFullscreenButton());
 document.addEventListener('webkitfullscreenchange', () => this.updateFullscreenButton());
 document.addEventListener('mozfullscreenchange', () => this.updateFullscreenButton());

 document.addEventListener('mousemove', (e) => this.continueSeeking(e));
 document.addEventListener('mouseup', () => this.endSeeking());

 document.addEventListener('touchmove', (e) => {
 if (this.isUserSeeking) {
 e.preventDefault(); // Prevent scrolling while seeking
 this.continueSeeking(e);
 }
 }, { passive: false });

 document.addEventListener('touchend', () => this.endSeeking());
 document.addEventListener('touchcancel', () => this.endSeeking());

 }

initAutoHide() {
 if (!this.options.autoHide) {
 if (this.options.debug) console.log('Auto-hide disabled in options');
 return;
 }

 if (this.autoHideInitialized) {
 if (this.options.debug) console.log('Auto-hide already initialized');
 return;
 }

 if (this.options.debug) console.log('Initializing auto-hide system');

 if (!this.container) {
 if (this.options.debug) console.error('Container not found! Auto-hide cannot work');
 return;
 }

 if (!this.controls) {
 if (this.options.debug) console.error('Controls not found! Auto-hide cannot work');
 return;
 }

 if (this.options.debug) console.log('DOM elements verified:', {
 container: !!this.container,
 controls: !!this.controls,
 video: !!this.video
 });

 this.showControlsNow();

 this.container.addEventListener('mousemove', (e) => {
 if (this.autoHideDebug) {
 if (this.options.debug) console.log('Mouse movement in container - reset timer');
 }
 this.onMouseMoveInPlayer(e);
 });

 if (this.options.debug) console.log('📡 Event listener mousemove added to container');

 this.controls.addEventListener('mouseenter', (e) => {
 if (this.autoHideDebug) {
 if (this.options.debug) console.log('Mouse ENTERS controls - cancel timer');
 }
 this.onMouseEnterControls(e);
 });

 this.controls.addEventListener('mouseleave', (e) => {
 if (this.autoHideDebug) {
 if (this.options.debug) console.log('Mouse EXITS controls - restart timer');

 this.container.addEventListener('touchstart', () => {
 this.showControlsNow();
 this.resetAutoHideTimer();
 });

 this.container.addEventListener('touchend', () => {
 this.resetAutoHideTimer();
 });
 }
 this.onMouseLeaveControls(e);
 });

 if (this.options.debug) console.log('Event listener mouseenter/mouseleave added to controls');

 this.autoHideInitialized = true;
 if (this.options.debug) console.log('Auto-hide system fully initialized');

 this.resetAutoHideTimer();
 if (this.options.debug) console.log('Initial timer started');
}

onMouseMoveInPlayer(e) {
 this.showControlsNow();
 this.resetAutoHideTimer();
}

onMouseEnterControls(e) {
 this.mouseOverControls = true;
 this.showControlsNow();

 if (this.autoHideTimer) {
 clearTimeout(this.autoHideTimer);
 this.autoHideTimer = null;
 if (this.autoHideDebug) {
 if (this.options.debug) console.log('Auto-hide timer cancelled');
 }
 }
}

onMouseLeaveControls(e) {
 this.mouseOverControls = false;
 this.resetAutoHideTimer();
}

resetAutoHideTimer() {
 if (this.autoHideTimer) {
 clearTimeout(this.autoHideTimer);
 this.autoHideTimer = null;
 }

 const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
 if (this.mouseOverControls && !isTouchDevice) {
 if (this.autoHideDebug) {
 if (this.options.debug) console.log('Not starting timer - mouse on controls');
 }
 return;
 }

 if (this.video && this.video.paused) {
 if (this.autoHideDebug) {
 if (this.options.debug) console.log('Not starting timer - video paused');
 }
 return;
 }

 this.autoHideTimer = setTimeout(() => {
 if (this.autoHideDebug) {
 if (this.options.debug) console.log(`Timer expired after ${this.options.autoHideDelay}ms - nascondo controlli`);
 }
 this.hideControlsNow();
 }, this.options.autoHideDelay);

 if (this.autoHideDebug) {
 if (this.options.debug) console.log(`Auto-hide timer started: ${this.options.autoHideDelay}ms`);
 }
}

showControlsNow() {
 if (this.controls) {
 this.controls.classList.add('show');
 }

 if (this.container) {
 this.container.classList.add('has-controls');
 this.updateControlbarHeight();

 if (this.updateWatermarkPosition) {
 this.updateWatermarkPosition();
 }
 }

 if (this.options.showTitleOverlay && !this.options.persistentTitle && this.options.videoTitle) {
 this.showTitleOverlay();
 }

 if (this.autoHideDebug && this.options.debug) console.log('✅ Controls shown');
}

hideControlsNow() {

 const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

 if (this.mouseOverControls && !isTouchDevice) {
 if (this.autoHideDebug && this.options.debug) {
 console.log('🚫 Not hiding - mouse still over controls');
 }
 return;
 }

 if (this.video && this.video.paused) {
 if (this.autoHideDebug && this.options.debug) {
 console.log('🚫 Not hiding - video is paused');
 }
 return;
 }

 if (this.controls) {
 this.controls.classList.remove('show');

 if (this.container) {
 this.container.classList.remove('has-controls');
 this.updateControlbarHeight();

 if (this.updateWatermarkPosition) {
 this.updateWatermarkPosition();
 }
 }
 }

 if (this.options.showTitleOverlay && !this.options.persistentTitle) {
 this.hideTitleOverlay();
 }

 if (this.autoHideDebug && this.options.debug) {
 console.log('👁️ Controls hidden');
 }
}

showControls() {
 this.showControlsNow();
 this.resetAutoHideTimer();
}

hideControls() {
 this.hideControlsNow();
}

hideControlsWithDelay() {
 this.resetAutoHideTimer();
}

clearControlsTimeout() {
 if (this.autoHideTimer) {
 clearTimeout(this.autoHideTimer);
 this.autoHideTimer = null;
 }
}

enableAutoHideDebug() {
 this.autoHideDebug = true;
 if (this.options.debug) console.log('AUTO-HIDE DEBUG ENABLED');
 if (this.options.debug) console.log('Stato attuale:', {
 initialized: this.autoHideInitialized,
 autoHide: this.options.autoHide,
 delay: this.options.autoHideDelay,
 mouseOverControls: this.mouseOverControls,
 timerActive: !!this.autoHideTimer,
 container: !!this.container,
 controls: !!this.controls,
 video: !!this.video,
 videoPaused: this.video ? this.video.paused : 'N/A'
 });

 if (!this.autoHideInitialized) {
 if (this.options.debug) console.log('Auto-hide NOT yet initialized! Initializing now...');
 this.initAutoHide();
 }
}

disableAutoHideDebug() {
 this.autoHideDebug = false;
 if (this.options.debug) console.log('Auto-hide debug disabled');
}

testAutoHide() {
 if (this.options.debug) console.log('TEST AUTO-HIDE COMPLETED:');
 if (this.options.debug) console.log('System status:', {
 initialized: this.autoHideInitialized,
 autoHide: this.options.autoHide,
 delay: this.options.autoHideDelay,
 mouseOverControls: this.mouseOverControls,
 timerActive: !!this.autoHideTimer
 });

 if (this.options.debug) console.log('Elementi DOM:', {
 container: !!this.container,
 controls: !!this.controls,
 video: !!this.video
 });

 if (this.options.debug) console.log('Stato video:', {
 paused: this.video ? this.video.paused : 'N/A',
 currentTime: this.video ? this.video.currentTime : 'N/A',
 duration: this.video ? this.video.duration : 'N/A'
 });

 if (!this.autoHideInitialized) {
 if (this.options.debug) console.log('PROBLEM: Auto-hide not initialized!');
 if (this.options.debug) console.log('Forcing initialization...');
 this.initAutoHide();
 } else {
 if (this.options.debug) console.log('Auto-hide initialized correctly');
 if (this.options.debug) console.log('Forcing timer reset for test...');
 this.resetAutoHideTimer();
 }
}

updateSubtitlesUI() {
 const subtitlesControl = this.controls?.querySelector('.subtitles-control');

 if (this.textTracks.length > 0 && this.options.showSubtitles) {
 if (subtitlesControl) {
 subtitlesControl.style.display = 'block';
 }
 this.populateSubtitlesMenu();
 } else {
 if (subtitlesControl) {
 subtitlesControl.style.display = 'none';
 }
 }
}

populateSubtitlesMenu() {
 const subtitlesMenu = this.controls?.querySelector('.subtitles-menu');
 if (!subtitlesMenu) return;

 let menuHTML = `<div class="subtitles-option ${!this.subtitlesEnabled ? 'active' : ''}" data-track="off">${this.t('subtitlesoff') || 'Off'}</div>`;

 this.textTracks.forEach((trackData, index) => {
 const isActive = this.currentSubtitleTrack === trackData.track;
 menuHTML += `<div class="subtitles-option ${isActive ? 'active' : ''}" data-track="${index}">${trackData.label}</div>`;
 });

 subtitlesMenu.innerHTML = menuHTML;
}

toggleSubtitles() {
 if (this.textTracks.length === 0) return;

 if (this.subtitlesEnabled) {
 this.disableSubtitles();
 } else {
 this.enableSubtitleTrack(0);
 }
}

updateSubtitlesButton() {
 const subtitlesBtn = this.controls?.querySelector('.subtitles-btn');
 if (!subtitlesBtn) return;

 if (this.subtitlesEnabled) {
 subtitlesBtn.classList.add('active');
 subtitlesBtn.title = this.t('subtitlesdisable') || 'Disable subtitles';
 } else {
 subtitlesBtn.classList.remove('active');
 subtitlesBtn.title = this.t('subtitlesenable') || 'Enable subtitles';
 }
}

handleSubtitlesMenuClick(e) {
 if (!e.target.classList.contains('subtitles-option')) return;

 const trackData = e.target.getAttribute('data-track');

 if (trackData === 'off') {
 this.disableSubtitles();
 } else {
 const trackIndex = parseInt(trackData);
 this.enableSubtitleTrack(trackIndex);
 }
}

hideNativePlayer() {
 this.video.controls = false;
 this.video.setAttribute('controls', 'false');
 this.video.removeAttribute('controls');
 this.video.style.visibility = 'hidden';
 this.video.style.opacity = '0';
 this.video.style.pointerEvents = 'none';
 this.video.classList.add('video-player');
}

createControls() {
 const controlsId = `videoControls-${this.getUniqueId()}`;

 const controlsHTML = `
 <div class="controls" id="${controlsId}">
 <div class="progress-container">
 <div class="progress-bar">
 <div class="progress-buffer"></div>
 <div class="progress-filled"></div>
 </div>
 <div class="progress-handle progress-handle-${this.options.seekHandleShape}"></div> <!-- ✅ Fuori da progress-bar -->
 ${this.options.showSeekTooltip ? '<div class="seek-tooltip">0:00</div>' : ''}
</div>

 <div class="controls-main">
 <div class="controls-left">
 <button class="control-btn play-pause-btn" data-tooltip="play_pause">
 <span class="icon play-icon">▶</span>
 <span class="icon pause-icon hidden">⏸</span>
 </button>

 <button class="control-btn mute-btn" data-tooltip="mute_unmute">
 <span class="icon volume-icon">🔊</span>
 <span class="icon mute-icon hidden">🔇</span>
 </button>

 <div class="volume-container" data-mobile-slider="${this.options.volumeSlider}">
 <input type="range" class="volume-slider" min="0" max="100" value="100" data-tooltip="volume">
 </div>

 <div class="time-display">
 <span class="current-time">0:00</span>
 <span>/</span>
 <span class="duration">0:00</span>
 </div>
 </div>

 <div class="controls-right">
 <button class="control-btn playlist-prev-btn" data-tooltip="prevvideo" style="display: none;">
 <span class="icon">⏮</span>
 </button>

 <button class="control-btn playlist-next-btn" data-tooltip="nextvideo" style="display: none;">
 <span class="icon">⏭</span>
 </button>

 ${this.options.showSubtitles ? `
 <div class="subtitles-control" style="display: none;">
 <button class="control-btn subtitles-btn" data-tooltip="subtitles">
 <span class="icon">CC</span>
 </button>
 <div class="subtitles-menu">
 <div class="subtitles-option active" data-track="off">Off</div>
 </div>
 </div>
 ` : ''}

 ${this.options.showSpeedControl ? `
 <div class="speed-control">
 <button class="control-btn speed-btn" data-tooltip="playback_speed">1x</button>
 <div class="speed-menu">
 <div class="speed-option" data-speed="0.5">0.5x</div>
 <div class="speed-option" data-speed="0.75">0.75x</div>
 <div class="speed-option active" data-speed="1">1x</div>
 <div class="speed-option" data-speed="1.25">1.25x</div>
 <div class="speed-option" data-speed="1.5">1.5x</div>
 <div class="speed-option" data-speed="2">2x</div>
 </div>
 </div>
 ` : ''}

 ${this.options.showQualitySelector && this.originalSources && this.originalSources.length > 1 ? `
 <div class="quality-control">
 <button class="control-btn quality-btn" data-tooltip="video_quality">
 <div class="quality-btn-text">
 <div class="selected-quality">${this.t('auto')}</div>
 <div class="current-quality"></div>
 </div>
 </button>
 <div class="quality-menu">
 <div class="quality-option selected" data-quality="auto">${this.t('auto')}</div>
 ${this.originalSources.map(s =>
 `<div class="quality-option" data-quality="${s.quality}">${s.quality}</div>`
 ).join('')}
 </div>
 </div>
 ` : ''}

 ${this.options.showPictureInPicture && this.isPiPSupported ? `
 <button class="control-btn pip-btn" data-tooltip="picture_in_picture">
 <span class="icon pip-icon">⧉</span>
 <span class="icon pip-exit-icon hidden">⧉</span>
 </button>
 ` : ''}

 <div class="settings-control">
 <button class="control-btn settings-btn" data-tooltip="settings_menu">
 <span class="">⚙</span>
 </button>
 <div class="settings-menu"></div>
 </div>

 ${this.options.showFullscreen ? `
 <button class="control-btn fullscreen-btn" data-tooltip="fullscreen">
 <span class="icon fullscreen-icon">⛶</span>
 <span class="icon exit-fullscreen-icon hidden">⛉</span>
 </button>
 ` : ''}
 </div>
 </div>
 </div>
 `;

 this.container.insertAdjacentHTML('beforeend', controlsHTML);
 this.controls = document.getElementById(controlsId);

 setTimeout(() => {
 this.initializeResponsiveMenu();
 this.updateControlbarHeight();
 }, 100);
}

initializeResponsiveMenu() {
 if (!this.controls) return;

 this.isSmallScreen = false;

 this.checkScreenSize();

 const resizeHandler = () => {
 this.checkScreenSize();
 this.updateControlbarHeight();
 };

 this.resizeHandler = resizeHandler.bind(this);
 window.addEventListener('resize', this.resizeHandler);

 this.bindSettingsMenuEvents();
}

updateControlbarHeight() {
 if (!this.controls) return;

 const height = this.controls.offsetHeight;
 if (this.container) {

 this.container.style.setProperty('--player-controls-height', `${height}px`);

 const watermark = this.container.querySelector('.video-watermark.watermark-bottomleft, .video-watermark.watermark-bottomright');
 if (watermark) {
 const hasControls = this.container.classList.contains('has-controls');
 const isHideOnAutoHide = watermark.classList.contains('hide-on-autohide');

 if (hasControls || !isHideOnAutoHide) {
 watermark.style.bottom = `${height + 15}px`;
 } else {
 watermark.style.bottom = '15px';
 }
 }
 }

 if (this.options.debug) {
 console.log(`Controlbar height updated: ${height}px`);
 }
}

getResponsiveThreshold() {

 const hasLogo = this.options.brandLogoEnabled && this.options.brandLogoUrl;

 return hasLogo ? 650 : 550;
}

checkScreenSize() {
 const threshold = this.getResponsiveThreshold();
 const newIsSmallScreen = window.innerWidth <= threshold;

 if (newIsSmallScreen !== this.isSmallScreen) {
 this.isSmallScreen = newIsSmallScreen;
 this.updateSettingsMenuVisibility();

 if (this.options.debug) {
 console.log(`Screen check: ${window.innerWidth}px vs ${threshold}px (threshold), logo: ${this.options.brandLogoEnabled}, small: ${this.isSmallScreen}`);
 }
 }
}

updateSettingsMenuVisibility() {
 const settingsControl = this.controls?.querySelector('.settings-control');
 if (!settingsControl) return;

 if (this.isSmallScreen) {

 settingsControl.style.display = 'block';

 const pipBtn = this.controls.querySelector('.pip-btn');
 const speedControl = this.controls.querySelector('.speed-control');
 const subtitlesControl = this.controls.querySelector('.subtitles-control');

 if (pipBtn) pipBtn.style.display = 'none';
 if (speedControl) speedControl.style.display = 'none';
 if (subtitlesControl) subtitlesControl.style.display = 'none';

 this.populateSettingsMenu();
 } else {

 settingsControl.style.display = 'none';

 const pipBtn = this.controls.querySelector('.pip-btn');
 const speedControl = this.controls.querySelector('.speed-control');
 const subtitlesControl = this.controls.querySelector('.subtitles-control');

 if (pipBtn && this.options.showPictureInPicture && this.isPiPSupported) {
 pipBtn.style.display = 'flex';
 }
 if (speedControl && this.options.showSpeedControl) {
 speedControl.style.display = 'block';
 }
 if (subtitlesControl && this.options.showSubtitles && this.textTracks.length > 0) {
 subtitlesControl.style.display = 'block';
 }
 }
}

populateSettingsMenu() {
 const settingsMenu = this.controls?.querySelector('.settings-menu');
 if (!settingsMenu) return;

 let menuHTML = '';

 if (this.options.showPictureInPicture && this.isPiPSupported) {
 const pipLabel = this.t('picture_in_picture') || 'Picture-in-Picture';
 menuHTML += `<div class="settings-option" data-action="pip">
 <span class="settings-option-label">${pipLabel}</span>
 </div>`;
 }

 if (this.options.showSpeedControl) {
 const speedLabel = this.t('playback_speed') || 'Playback Speed';
 const currentSpeed = this.video ? this.video.playbackRate : 1;

 menuHTML += `
 <div class="settings-expandable-wrapper">
 <div class="settings-option expandable-trigger" data-action="speed-expand">
 <span class="settings-option-label">${speedLabel}: ${currentSpeed}x</span>
 <span class="expand-arrow">▼</span>
 </div>
 <div class="settings-expandable-content" style="display: none;">`;

 const speeds = [0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2];
 speeds.forEach(speed => {
 const isActive = Math.abs(speed - currentSpeed) < 0.01;
 menuHTML += `<div class="settings-suboption ${isActive ? 'active' : ''}" data-speed="${speed}">${speed}x</div>`;
 });

 menuHTML += `</div></div>`;
 }

 if (this.options.showSubtitles && this.textTracks && this.textTracks.length > 0) {
 const subtitlesLabel = this.t('subtitles') || 'Subtitles';
 const currentTrack = this.currentSubtitleTrack;
 const currentLabel = this.subtitlesEnabled && currentTrack ? currentTrack.label : (this.t('subtitlesoff') || 'Off');

 menuHTML += `
 <div class="settings-expandable-wrapper">
 <div class="settings-option expandable-trigger" data-action="subtitles-expand">
 <span class="settings-option-label">${subtitlesLabel}: ${currentLabel}</span>
 <span class="expand-arrow">▼</span>
 </div>
 <div class="settings-expandable-content" style="display: none;">`;

 menuHTML += `<div class="settings-suboption ${!this.subtitlesEnabled ? 'active' : ''}" data-track="off">${this.t('subtitlesoff') || 'Off'}</div>`;

 this.textTracks.forEach((trackData, index) => {
 const isActive = this.currentSubtitleTrack === trackData.track;
 menuHTML += `<div class="settings-suboption ${isActive ? 'active' : ''}" data-track="${index}">${trackData.label}</div>`;
 });

 menuHTML += `</div></div>`;
 }

 settingsMenu.innerHTML = menuHTML;

 this.addSettingsMenuScrollbar();
}

addSettingsMenuScrollbar() {
 const settingsMenu = this.controls?.querySelector('.settings-menu');
 if (!settingsMenu) return;

 const playerHeight = this.container.offsetHeight;
 const maxMenuHeight = playerHeight - 100;

 settingsMenu.style.maxHeight = `${maxMenuHeight}px`;
 settingsMenu.style.overflowY = 'auto';
 settingsMenu.style.overflowX = 'hidden';

 if (!document.getElementById('player-settings-scrollbar-style')) {
 const scrollbarStyle = document.createElement('style');
 scrollbarStyle.id = 'player-settings-scrollbar-style';
 scrollbarStyle.textContent = `
 .settings-menu::-webkit-scrollbar {
 width: 6px;
 }
 .settings-menu::-webkit-scrollbar-track {
 background: rgba(255,255,255,0.05);
 border-radius: 3px;
 }
 .settings-menu::-webkit-scrollbar-thumb {
 background: rgba(255,255,255,0.3);
 border-radius: 3px;
 }
 .settings-menu::-webkit-scrollbar-thumb:hover {
 background: rgba(255,255,255,0.5);
 }
 `;
 document.head.appendChild(scrollbarStyle);
 }

 settingsMenu.style.scrollbarWidth = 'thin';
 settingsMenu.style.scrollbarColor = 'rgba(255,255,255,0.3) transparent';
}

bindSettingsMenuEvents() {
 const settingsMenu = this.controls?.querySelector('.settings-menu');
 if (!settingsMenu) return;

 settingsMenu.addEventListener('click', (e) => {
 e.stopPropagation();

 if (e.target.classList.contains('expandable-trigger') || e.target.closest('.expandable-trigger')) {
 const trigger = e.target.classList.contains('expandable-trigger') ? e.target : e.target.closest('.expandable-trigger');
 const wrapper = trigger.closest('.settings-expandable-wrapper');
 const content = wrapper.querySelector('.settings-expandable-content');
 const arrow = trigger.querySelector('.expand-arrow');

 const isExpanded = content.style.display !== 'none';

 if (isExpanded) {
 content.style.display = 'none';
 arrow.style.transform = 'rotate(0deg)';
 } else {
 content.style.display = 'block';
 arrow.style.transform = 'rotate(180deg)';
 }
 return;
 }

 if (e.target.classList.contains('settings-option') || e.target.closest('.settings-option')) {
 const option = e.target.classList.contains('settings-option') ? e.target : e.target.closest('.settings-option');
 const action = option.getAttribute('data-action');

 if (action === 'pip') {
 this.togglePictureInPicture();
 return;
 }
 }

 if (e.target.classList.contains('settings-suboption')) {
 const wrapper = e.target.closest('.settings-expandable-wrapper');
 const trigger = wrapper.querySelector('.expandable-trigger');
 const action = trigger.getAttribute('data-action');

 if (action === 'speed-expand') {
 const speed = parseFloat(e.target.getAttribute('data-speed'));
 if (speed && speed > 0 && this.video && !this.isChangingQuality) {
 this.video.playbackRate = speed;

 wrapper.querySelectorAll('.settings-suboption').forEach(opt => opt.classList.remove('active'));
 e.target.classList.add('active');

 const label = trigger.querySelector('.settings-option-label');
 if (label) {
 const speedLabel = this.t('playback_speed') || 'Playback Speed';
 label.textContent = `${speedLabel}: ${speed}x`;
 }

 this.triggerEvent('speedchange', { speed, previousSpeed: this.video.playbackRate });
 }
 } else if (action === 'subtitles-expand') {
 const trackData = e.target.getAttribute('data-track');
 if (trackData === 'off') {
 this.disableSubtitles();
 } else {
 const trackIndex = parseInt(trackData);
 this.enableSubtitleTrack(trackIndex);
 }

 wrapper.querySelectorAll('.settings-suboption').forEach(opt => opt.classList.remove('active'));
 e.target.classList.add('active');

 const label = trigger.querySelector('.settings-option-label');
 if (label) {
 const subtitlesLabel = this.t('subtitles') || 'Subtitles';
 label.textContent = `${subtitlesLabel}: ${e.target.textContent}`;
 }
 }
 }
 });
}

showTitleOverlay() {
 if (this.titleOverlay && this.options.videoTitle) {
 this.titleOverlay.classList.add('show');

 if (this.options.persistentTitle) {
 this.titleOverlay.classList.add('persistent');
 } else {
 this.titleOverlay.classList.remove('persistent');
 }
 }
 return this;
}

hideTitleOverlay() {
 if (this.titleOverlay) {
 this.titleOverlay.classList.remove('show');
 this.titleOverlay.classList.remove('persistent');
 }
 return this;
}

toggleTitleOverlay(show = null) {
 if (show === null) {
 return this.titleOverlay && this.titleOverlay.classList.contains('show')
 ? this.hideTitleOverlay()
 : this.showTitleOverlay();
 }

 return show ? this.showTitleOverlay() : this.hideTitleOverlay();
}

setupKeyboardControls() {
 document.addEventListener('keydown', (e) => {

 if (document.activeElement && document.activeElement.tagName === 'INPUT') return;

 if (this.options.autoHide && this.autoHideInitialized) {
 this.showControlsNow();
 this.resetAutoHideTimer();
 }

 switch (e.code) {
 case 'Space':
 e.preventDefault();
 this.togglePlayPause();
 break;
 case 'KeyM':
 this.toggleMute();
 break;
 case 'KeyF':
 if (this.options.showFullscreen) {
 this.toggleFullscreen();
 }
 break;
 case 'KeyP':
 if (this.options.showPictureInPicture && this.isPiPSupported) {
 this.togglePictureInPicture();
 }
 break;
 case 'KeyT':
 if (this.options.showTitleOverlay) {
 this.toggleTitleOverlay();
 }
 break;
 case 'KeyS':
 if (this.options.showSubtitles) {
 this.toggleSubtitles();
 }
 break;
 case 'KeyD':
 this.debugQuality ? this.disableQualityDebug() : this.enableQualityDebug();
 break;
 case 'ArrowLeft':
 e.preventDefault();
 this.skipTime(-10);
 break;
 case 'ArrowRight':
 e.preventDefault();
 this.skipTime(10);
 break;
 case 'ArrowUp':
 e.preventDefault();
 this.changeVolume(0.1);
 break;
 case 'ArrowDown':
 e.preventDefault();
 this.changeVolume(-0.1);
 break;
 }
 });
}

togglePlayPause() {
 if (!this.video || this.isChangingQuality) return;

 if (this.video.paused) {
 this.play();
 } else {
 this.pause();
 }
}

toggleMute() {
 if (!this.video) return;

 const wasMuted = this.video.muted;
 this.video.muted = !this.video.muted;

 this.updateMuteButton();
 this.updateVolumeSliderVisual();
 this.initVolumeTooltip();

 this.triggerEvent('volumechange', {
 volume: this.getVolume(),
 muted: this.isMuted(),
 previousMuted: wasMuted
 });
}

updateMuteButton() {
 if (!this.video || !this.volumeIcon || !this.muteIcon) return;

 if (this.video.muted || this.video.volume === 0) {
 this.volumeIcon.classList.add('hidden');
 this.muteIcon.classList.remove('hidden');
 } else {
 this.volumeIcon.classList.remove('hidden');
 this.muteIcon.classList.add('hidden');
 }
}

showLoading() {
 if (this.loadingOverlay) {
 this.loadingOverlay.classList.add('active');
 }
}

hideLoading() {
 if (this.loadingOverlay) {
 this.loadingOverlay.classList.remove('active');
 }
}

toggleFullscreen() {
 if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement) {
 this.exitFullscreen();
 } else {
 this.enterFullscreen();
 }
}

updateFullscreenButton() {
 if (!this.fullscreenIcon || !this.exitFullscreenIcon) return;

 const isFullscreen = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement;

 if (isFullscreen) {
 this.fullscreenIcon.classList.add('hidden');
 this.exitFullscreenIcon.classList.remove('hidden');
 } else {
 this.fullscreenIcon.classList.remove('hidden');
 this.exitFullscreenIcon.classList.add('hidden');
 }

 this.triggerEvent('fullscreenchange', {
 active: !!isFullscreen,
 mode: isFullscreen ? 'enter' : 'exit'
 });
}

togglePictureInPicture() {
 if (!this.isPiPSupported || !this.video) return;

 if (document.pictureInPictureElement) {
 this.exitPictureInPicture();
 } else {
 this.enterPictureInPicture();
 }
}

toggleSeekTooltip(show = null) {
 if (show === null) {
 this.options.showSeekTooltip = !this.options.showSeekTooltip;
 } else {
 this.options.showSeekTooltip = show;
 }

 if (this.seekTooltip) {
 if (this.options.showSeekTooltip) {
 this.setupSeekTooltip();
 } else {
 this.seekTooltip.classList.remove('visible');
 }
 }
}

setAutoHideDelay(delay) {
 if (typeof delay === 'number' && delay >= 0) {
 this.options.autoHideDelay = delay;
 if (this.options.debug) console.log(`Auto-hide delay set to ${delay}ms`);
 }
 return this;
}

getAutoHideDelay() {
 return this.options.autoHideDelay;
}

enableAutoHide() {
 if (!this.options.autoHide) {
 this.options.autoHide = true;
 if (!this.autoHideInitialized) {
 this.initAutoHide();
 }
 if (this.options.debug) console.log('Auto-hide enabled');
 }
 return this;
}

disableAutoHide() {
 if (this.options.autoHide) {
 this.options.autoHide = false;
 if (this.autoHideTimer) {
 clearTimeout(this.autoHideTimer);
 this.autoHideTimer = null;
 }
 this.showControlsNow();
 if (this.options.debug) console.log('Auto-hide disabled');
 }
 return this;
}

forceShowControls() {
 this.showControlsNow();
 if (this.autoHideInitialized) {
 this.resetAutoHideTimer();
 }
 return this;
}

forceHideControls() {
 if (!this.mouseOverControls && this.video && !this.video.paused) {
 this.hideControlsNow();
 }
 return this;
}

isAutoHideEnabled() {
 return this.options.autoHide;
}

isAutoHideInitialized() {
 return this.autoHideInitialized;
}

showPlaylistControls() {
 if (!this.playlistPrevBtn || !this.playlistNextBtn) return;

 this.playlistPrevBtn.style.display = 'flex';
 this.playlistNextBtn.style.display = 'flex';
 this.updatePlaylistButtons();

 if (this.options.debug) console.log('Playlist controls shown');
}

hidePlaylistControls() {
 if (!this.playlistPrevBtn || !this.playlistNextBtn) return;

 this.playlistPrevBtn.style.display = 'none';
 this.playlistNextBtn.style.display = 'none';

 if (this.options.debug) console.log('Playlist controls hidden');
}

updatePlaylistButtons() {
 if (!this.playlistPrevBtn || !this.playlistNextBtn || !this.isPlaylistActive) return;

 const canGoPrev = this.currentPlaylistIndex > 0 || this.options.playlistLoop;
 const canGoNext = this.currentPlaylistIndex < this.playlist.length - 1 || this.options.playlistLoop;

 this.playlistPrevBtn.disabled = !canGoPrev;
 this.playlistNextBtn.disabled = !canGoNext;

 if (canGoPrev) {
 this.playlistPrevBtn.style.opacity = '1';
 this.playlistPrevBtn.style.cursor = 'pointer';
 } else {
 this.playlistPrevBtn.style.opacity = '0.4';
 this.playlistPrevBtn.style.cursor = 'not-allowed';
 }

 if (canGoNext) {
 this.playlistNextBtn.style.opacity = '1';
 this.playlistNextBtn.style.cursor = 'pointer';
 } else {
 this.playlistNextBtn.style.opacity = '0.4';
 this.playlistNextBtn.style.cursor = 'not-allowed';
 }
}

optimizeButtonsForSmallHeight() {
 const currentHeight = window.innerHeight;
 const controlsRect = this.controls.getBoundingClientRect();

 if (controlsRect.height > currentHeight * 0.4) {
 this.controls.classList.add('ultra-compact');
 if (this.options.debug) console.log('Applied ultra-compact mode for height:', currentHeight);
 } else {
 this.controls.classList.remove('ultra-compact');
 }

 const nonEssentialButtons = this.controls.querySelectorAll('.pip-btn, .speed-control');
 if (currentHeight < 180) {
 nonEssentialButtons.forEach(btn => btn.style.display = 'none');
 } else {
 nonEssentialButtons.forEach(btn => btn.style.display = '');
 }
}

initializeQualityMonitoring() {
 this.qualityMonitorInterval = setInterval(() => {
 if (!this.isChangingQuality) {
 this.updateCurrentPlayingQuality();
 }
 }, 3000);

 if (this.video) {
 this.video.addEventListener('loadedmetadata', () => {
 setTimeout(() => {
 if (!this.isChangingQuality) {
 this.updateCurrentPlayingQuality();
 }
 }, 100);
 });

 this.video.addEventListener('resize', () => {
 if (!this.isChangingQuality) {
 this.updateCurrentPlayingQuality();
 }
 });

 this.video.addEventListener('loadeddata', () => {
 setTimeout(() => {
 if (!this.isChangingQuality) {
 this.updateCurrentPlayingQuality();
 }
 }, 1000);
 });
 }
}

getCurrentPlayingQuality() {
 if (!this.video) return null;

 if (this.video.currentSrc && this.qualities && this.qualities.length > 0) {
 const currentSource = this.qualities.find(q => {
 const currentUrl = this.video.currentSrc.toLowerCase();
 const qualityUrl = q.src.toLowerCase();

 if (this.debugQuality) {
 if (this.options.debug) console.log('Quality comparison:', {
 current: currentUrl,
 quality: qualityUrl,
 qualityName: q.quality,
 match: currentUrl === qualityUrl || currentUrl.includes(qualityUrl) || qualityUrl.includes(currentUrl)
 });
 }

 return currentUrl === qualityUrl ||
 currentUrl.includes(qualityUrl) ||
 qualityUrl.includes(currentUrl);
 });

 if (currentSource) {
 if (this.debugQuality) {
 if (this.options.debug) console.log('Quality found from source:', currentSource.quality);
 }
 return currentSource.quality;
 }
 }

 if (this.video.videoHeight && this.video.videoWidth) {
 const height = this.video.videoHeight;
 const width = this.video.videoWidth;

 if (this.debugQuality) {
 if (this.options.debug) console.log('Risoluzione video:', { height, width });
 }

 if (height >= 2160) return '4K';
 if (height >= 1440) return '1440p';
 if (height >= 1080) return '1080p';
 if (height >= 720) return '720p';
 if (height >= 480) return '480p';
 if (height >= 360) return '360p';
 if (height >= 240) return '240p';

 return `${height}p`;
 }

 if (this.debugQuality) {
 if (this.options.debug) console.log('No quality detected:', {
 currentSrc: this.video.currentSrc,
 videoHeight: this.video.videoHeight,
 videoWidth: this.video.videoWidth,
 qualities: this.qualities
 });
 }

 return null;
}

updateCurrentPlayingQuality() {
 const newPlayingQuality = this.getCurrentPlayingQuality();

 if (newPlayingQuality && newPlayingQuality !== this.currentPlayingQuality) {
 if (this.options.debug) console.log(`Quality changed: ${this.currentPlayingQuality} → ${newPlayingQuality}`);
 this.currentPlayingQuality = newPlayingQuality;
 this.updateQualityDisplay();
 }
}

updateQualityDisplay() {
 this.updateQualityButton();
 this.updateQualityMenu();
}

updateQualityButton() {
 const qualityBtn = this.controls?.querySelector('.quality-btn');
 if (!qualityBtn) return;

 let btnText = qualityBtn.querySelector('.quality-btn-text');
 if (!btnText) {

 qualityBtn.textContent = ''; // Clear existing content

 const iconSpan = document.createElement('span');
 iconSpan.className = 'icon';
 iconSpan.textContent = '⚙';
 qualityBtn.appendChild(iconSpan);

 btnText = document.createElement('div');
 btnText.className = 'quality-btn-text';

 const selectedQualityDiv = document.createElement('div');
 selectedQualityDiv.className = 'selected-quality';
 selectedQualityDiv.textContent = this.selectedQuality === 'auto' ? this.t('auto') : this.selectedQuality;
 btnText.appendChild(selectedQualityDiv);

 const currentQualityDiv = document.createElement('div');
 currentQualityDiv.className = 'current-quality';
 currentQualityDiv.textContent = this.currentPlayingQuality || '';
 btnText.appendChild(currentQualityDiv);

 qualityBtn.appendChild(btnText);
 } else {

 const selectedEl = btnText.querySelector('.selected-quality');
 const currentEl = btnText.querySelector('.current-quality');

 if (selectedEl) {
 selectedEl.textContent = this.selectedQuality === 'auto' ? this.t('auto') : this.selectedQuality;
 }

 if (currentEl) {
 currentEl.textContent = this.currentPlayingQuality || '';
 }
 }
}

updateQualityMenu() {
 const qualityMenu = this.controls?.querySelector('.quality-menu');
 if (!qualityMenu) return;

 let menuHTML = '';

 if (this.isAdaptiveStream && this.adaptiveQualities && this.adaptiveQualities.length > 0) {

 const currentIndex = this.getCurrentAdaptiveQuality();
 const autoSelected = currentIndex === -1 || currentIndex === null || this.selectedQuality === 'auto';
 const autoClass = autoSelected ? 'selected' : '';

 menuHTML += `<div class="quality-option ${autoClass}" data-adaptive-quality="auto">${this.t('auto')}</div>`;

 this.adaptiveQualities.forEach(quality => {
 const isSelected = currentIndex === quality.index && !autoSelected;
 const className = isSelected ? 'selected' : '';
 const label = quality.label || `${quality.height}p` || 'Unknown';
 menuHTML += `<div class="quality-option ${className}" data-adaptive-quality="${quality.index}">${label}</div>`;
 });
 } else {

 const autoSelected = this.selectedQuality === 'auto';
 const autoPlaying = this.selectedQuality === 'auto' && this.currentPlayingQuality;
 let autoClass = '';
 if (autoSelected && autoPlaying) {
 autoClass = 'selected playing';
 } else if (autoSelected) {
 autoClass = 'selected';
 }

 menuHTML += `<div class="quality-option ${autoClass}" data-quality="auto">${this.t('auto')}</div>`;

 this.qualities.forEach(quality => {
 const isSelected = this.selectedQuality === quality.quality;
 const isPlaying = this.currentPlayingQuality === quality.quality;
 let className = 'quality-option';
 if (isSelected && isPlaying) {
 className += ' selected playing';
 } else if (isSelected) {
 className += ' selected';
 } else if (isPlaying) {
 className += ' playing';
 }
 menuHTML += `<div class="${className}" data-quality="${quality.quality}">${quality.quality}</div>`;
 });
 }

 qualityMenu.innerHTML = menuHTML;
}

getQualityStatus() {
 return {
 selected: this.selectedQuality,
 playing: this.currentPlayingQuality,
 isAuto: this.selectedQuality === 'auto',
 isChanging: this.isChangingQuality
 };
}

getSelectedQuality() {
 return this.selectedQuality;
}

isAutoQualityActive() {
 return this.selectedQuality === 'auto';
}

enableQualityDebug() {
 this.debugQuality = true;
 this.enableAutoHideDebug(); // Abilita anche debug auto-hide
 if (this.options.debug) console.log('Quality AND auto-hide debug enabled');
 this.updateCurrentPlayingQuality();
}

disableQualityDebug() {
 this.debugQuality = false;
 this.disableAutoHideDebug();
 if (this.options.debug) console.log('Quality AND auto-hide debug disabled');
}

changeQuality(e) {
 if (!e.target.classList.contains('quality-option')) return;
 if (this.isChangingQuality) return;

 const adaptiveQuality = e.target.getAttribute('data-adaptive-quality');
 if (adaptiveQuality !== null && this.isAdaptiveStream) {
 const qualityIndex = adaptiveQuality === 'auto' ? -1 : parseInt(adaptiveQuality);
 this.setAdaptiveQuality(qualityIndex);
 this.updateAdaptiveQualityMenu();
 return;
 }

 const quality = e.target.getAttribute('data-quality');
 if (!quality || quality === this.selectedQuality) return;

 if (this.options.debug) console.log(`Quality change requested: ${this.selectedQuality} → ${quality}`);

 this.selectedQuality = quality;

 if (quality === 'auto') {
 this.enableAutoQuality();
 } else {
 this.setQuality(quality);
 }

 this.updateQualityDisplay();
}

setQuality(targetQuality) {
 if (this.options.debug) console.log(`setQuality("${targetQuality}") called`);

 if (!targetQuality) {
 if (this.options.debug) console.error('targetQuality is empty!');
 return;
 }

 if (!this.video || !this.qualities || this.qualities.length === 0) return;
 if (this.isChangingQuality) return;

 const newSource = this.qualities.find(q => q.quality === targetQuality);
 if (!newSource || !newSource.src) {
 if (this.options.debug) console.error(`Quality "${targetQuality}" not found`);
 return;
 }

 const currentTime = this.video.currentTime || 0;
 const wasPlaying = !this.video.paused;

 this.isChangingQuality = true;
 this.selectedQuality = targetQuality;
 this.video.pause();

 this.showLoading();
 if (this.video.classList) {
 this.video.classList.add('quality-changing');
 }

 const onLoadedData = () => {
 if (this.options.debug) console.log(`Quality ${targetQuality} applied!`);
 this.video.currentTime = currentTime;

 if (wasPlaying) {
 this.video.play().catch(e => {
 if (this.options.debug) console.log('Play error:', e);
 });
 }

 this.currentPlayingQuality = targetQuality;
 this.updateQualityDisplay();
 this.isChangingQuality = false;

 this.restoreResolutionAfterQualityChange();
 cleanup();
 };

 const onError = (error) => {
 if (this.options.debug) console.error(`Loading error ${targetQuality}:`, error);
 this.isChangingQuality = false;

 this.onVideoError(error);

 cleanup();
 };

 const cleanup = () => {
 this.video.removeEventListener('loadeddata', onLoadedData);
 this.video.removeEventListener('error', onError);
 };

 this.video.addEventListener('loadeddata', onLoadedData, { once: true });
 this.video.addEventListener('error', onError, { once: true });

 this.video.src = newSource.src;
 this.video.load();
}

finishQualityChange(success, wasPlaying, currentTime, currentVolume, wasMuted, targetQuality) {
 if (this.options.debug) console.log(`Quality change completion: success=${success}, target=${targetQuality}`);

 if (this.qualityChangeTimeout) {
 clearTimeout(this.qualityChangeTimeout);
 this.qualityChangeTimeout = null;
 }

 if (this.video) {
 try {
 if (success && currentTime > 0 && this.video.duration) {
 this.video.currentTime = Math.min(currentTime, this.video.duration);
 }

 this.video.volume = currentVolume;
 this.video.muted = wasMuted;

 if (success && wasPlaying) {
 this.video.play().catch(err => {
 if (this.options.debug) console.warn('Play after quality change failed:', err);
 });
 }
 } catch (error) {
 if (this.options.debug) console.error('Errore ripristino stato:', error);
 }

 if (this.video.classList) {
 this.video.classList.remove('quality-changing');
 }
 }

 this.hideLoading();
 this.isChangingQuality = false;

 if (success) {
 if (this.options.debug) console.log('Quality change completed successfully');
 setTimeout(() => {
 this.currentPlayingQuality = targetQuality;
 this.updateQualityDisplay();
 if (this.options.debug) console.log(`🎯 Quality confirmed active: ${targetQuality}`);
 }, 100);
 } else {
 if (this.options.debug) console.warn('Quality change failed or timeout');
 }

 setTimeout(() => {
 this.updateCurrentPlayingQuality();
 }, 2000);
}

cleanupQualityChange() {
 if (this.qualityChangeTimeout) {
 clearTimeout(this.qualityChangeTimeout);
 this.qualityChangeTimeout = null;
 }
}

enableAutoQuality() {
 if (this.options.debug) console.log('🔄 enableAutoQuality - keeping selectedQuality as "auto"');

 this.selectedQuality = 'auto';

 if (!this.qualities || this.qualities.length === 0) {
 if (this.options.debug) console.warn('⚠️ No qualities available for auto selection');
 this.updateQualityDisplay();
 return;
 }

 let autoSelectedQuality = this.getAutoQualityBasedOnConnection();

 if (this.options.debug) {
 console.log('🎯 Auto quality selected:', autoSelectedQuality);
 console.log('📊 selectedQuality remains: "auto" (for UI)');
 }

 this.applyAutoQuality(autoSelectedQuality);
}

getAutoQualityBasedOnConnection() {

 const maxQualityIndex = this.qualities.length - 1;
 const maxQuality = this.qualities[maxQualityIndex];
 let selectedQuality = maxQuality.quality;

 const isDefinitelyMobile = () => {
 const ua = navigator.userAgent.toLowerCase();
 const checks = [
 ua.includes('android'),
 ua.includes('mobile'),
 ua.includes('iphone'),
 ua.includes('ipad'),
 window.innerWidth < 1024,
 window.innerHeight < 768,
 'ontouchstart' in window,
 navigator.maxTouchPoints > 0,
 'orientation' in window,
 window.devicePixelRatio > 1.5
 ];

 const mobileScore = checks.filter(Boolean).length;

 if (this.options.debug) {
 console.log('🔍 Mobile Detection Score:', {
 score: mobileScore + '/10',
 android: ua.includes('android'),
 mobile: ua.includes('mobile'),
 width: window.innerWidth,
 touch: 'ontouchstart' in window,
 maxTouch: navigator.maxTouchPoints
 });
 }

 return mobileScore >= 4; // Threshold: 4 out of 10 checks
 };

 if (isDefinitelyMobile()) {

 const findMobileQuality = (maxHeight) => {
 const mobileQualities = this.qualities
 .filter(q => q.height && q.height <= maxHeight)
 .sort((a, b) => b.height - a.height);
 return mobileQualities[0] || maxQuality;
 };

 const mobileQuality = findMobileQuality(1080);

 if (this.options.debug) console.log('🚨 MOBILE FORCE OVERRIDE: ' + mobileQuality.quality + ' (max 1080p)');
 return mobileQuality.quality;
 }

 const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;

 if (connection) {
 const physicalType = connection.type; // Usually undefined
 const downlinkSpeed = connection.downlink || 0;
 const rtt = connection.rtt; // Round Trip Time in milliseconds

 if (this.options.debug) {
 console.log('🌐 Enhanced Connection Detection:', {
 physicalType: physicalType || 'undefined',
 downlink: downlinkSpeed + ' Mbps',
 rtt: rtt + ' ms',
 userAgent: navigator.userAgent.includes('Mobile') ? 'Mobile' : 'Desktop'
 });
 }

 const isMobileDevice = () => {
 return /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
 };

 const findQualityByMinHeight = (minHeight) => {

 const sortedQualities = this.qualities
 .filter(q => q.height && q.height >= minHeight)
 .sort((a, b) => b.height - a.height);

 return sortedQualities[0] || maxQuality;
 };

 const findHighestQuality = () => {
 const sortedQualities = this.qualities
 .filter(q => q.height)
 .sort((a, b) => b.height - a.height);

 return sortedQualities[0] || maxQuality;
 };

 if (physicalType === 'ethernet') {
 const quality = findHighestQuality(); // Maximum available quality
 if (this.options.debug) console.log('🔥 Ethernet Detected: ' + quality.quality);
 return quality.quality;
 }

 if (physicalType === 'wifi') {
 const quality = findQualityByMinHeight(1440) || findHighestQuality(); // 2K preferred
 if (this.options.debug) console.log('📶 WiFi Detected: ' + quality.quality);
 return quality.quality;
 }

 if (physicalType === 'cellular') {

 if (downlinkSpeed >= 20 && rtt < 40) {
 const quality = findQualityByMinHeight(1080); // Max 1080p for excellent mobile
 if (this.options.debug) console.log('📱 Excellent Cellular: ' + quality.quality);
 return quality.quality;
 } else if (downlinkSpeed >= 10) {
 const quality = findQualityByMinHeight(720); // 720p for good mobile
 if (this.options.debug) console.log('📱 Good Cellular: ' + quality.quality);
 return quality.quality;
 } else {
 const quality = findQualityByMinHeight(480); // 480p for standard mobile
 if (this.options.debug) console.log('📱 Standard Cellular: ' + quality.quality);
 return quality.quality;
 }
 }

 if (this.options.debug) {
 console.log('🌐 Physical type undefined - using enhanced RTT + UA heuristics');
 }

 if (rtt === 0) {
 if (isMobileDevice()) {

 const quality = findQualityByMinHeight(1080); // Max 1080p for mobile
 if (this.options.debug) console.log('📱 Mobile Device (UA) with RTT=0: ' + quality.quality);
 return quality.quality;
 } else {

 const quality = findHighestQuality();
 if (this.options.debug) console.log('🚀 Desktop Ultra-Fast (RTT=0): ' + quality.quality);
 return quality.quality;
 }
 }

 if (rtt < 20 && downlinkSpeed >= 10) {
 if (isMobileDevice()) {
 if (rtt < 10 && downlinkSpeed >= 15) {

 const quality = findQualityByMinHeight(1080); // Max 1080p for excellent mobile
 if (this.options.debug) console.log('📱 Mobile 5G Ultra-Fast (RTT<10): ' + quality.quality);
 return quality.quality;
 } else {

 const quality = findQualityByMinHeight(720); // 720p for mobile with good RTT
 if (this.options.debug) console.log('📱 Mobile Good Connection (RTT<20): ' + quality.quality);
 return quality.quality;
 }
 } else {

 const quality = findQualityByMinHeight(1440) || findHighestQuality(); // 2K or best available
 if (this.options.debug) console.log('🔥 Desktop High-Speed Fixed (RTT<20): ' + quality.quality);
 return quality.quality;
 }
 }

 if (rtt < 40 && downlinkSpeed >= 8) {
 if (isMobileDevice()) {

 const quality = findQualityByMinHeight(720); // 720p for mobile
 if (this.options.debug) console.log('📱 Mobile Decent Connection (RTT<40): ' + quality.quality);
 return quality.quality;
 } else {

 const quality = findQualityByMinHeight(1080); // 1080p for desktop
 if (this.options.debug) console.log('⚡ Desktop Good Connection (RTT<40): ' + quality.quality);
 return quality.quality;
 }
 }

 if (rtt >= 40) {
 if (downlinkSpeed >= 15 && !isMobileDevice()) {

 const quality = findQualityByMinHeight(1080); // 1080p
 if (this.options.debug) console.log('🌐 Desktop Congested Fast Connection: ' + quality.quality);
 return quality.quality;
 } else if (downlinkSpeed >= 10) {

 const quality = findQualityByMinHeight(720); // 720p
 if (this.options.debug) console.log('📱 Mobile/Congested Connection (RTT≥40): ' + quality.quality);
 return quality.quality;
 } else {

 const quality = findQualityByMinHeight(480); // 480p
 if (this.options.debug) console.log('📱 Slow Mobile Connection: ' + quality.quality);
 return quality.quality;
 }
 }

 if (downlinkSpeed >= 8) {
 if (isMobileDevice()) {
 const quality = findQualityByMinHeight(720); // Conservative for mobile
 if (this.options.debug) console.log('📱 Mobile Standard Speed: ' + quality.quality);
 return quality.quality;
 } else {
 const quality = findQualityByMinHeight(1080); // Good for desktop
 if (this.options.debug) console.log('🌐 Desktop Standard Speed: ' + quality.quality);
 return quality.quality;
 }
 } else if (downlinkSpeed >= 5) {

 const quality = findQualityByMinHeight(720);
 if (this.options.debug) console.log('🌐 Lower Speed Connection: ' + quality.quality);
 return quality.quality;
 } else {

 const quality = findQualityByMinHeight(480);
 if (this.options.debug) console.log('🌐 Very Low Speed Connection: ' + quality.quality);
 return quality.quality;
 }

 } else {

 const isMobileDevice = () => {
 return /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
 };

 const findQualityByMinHeight = (minHeight) => {
 const sortedQualities = this.qualities
 .filter(q => q.height && q.height >= minHeight)
 .sort((a, b) => b.height - a.height);
 return sortedQualities[0] || maxQuality;
 };

 if (isMobileDevice()) {

 const quality = findQualityByMinHeight(720);
 if (this.options.debug) console.log('📱 Mobile - No Connection Info: ' + quality.quality);
 return quality.quality;
 } else {

 const quality = findQualityByMinHeight(1080) || maxQuality;
 if (this.options.debug) console.log('🌐 Desktop - No Connection Info: ' + quality.quality);
 return quality.quality;
 }
 }

 if (this.options.debug) console.log('🌐 Fallback to max quality: ' + maxQuality.quality);
 return maxQuality.quality;
}

applyAutoQuality(targetQuality) {
 if (!targetQuality || !this.video || !this.qualities || this.qualities.length === 0) {
 return;
 }

 if (this.isChangingQuality) return;

 const newSource = this.qualities.find(q => q.quality === targetQuality);
 if (!newSource || !newSource.src) {
 if (this.options.debug) console.error('Auto quality', targetQuality, 'not found');
 return;
 }

 const currentResolution = this.getCurrentResolution();

 const currentTime = this.video.currentTime || 0;
 const wasPlaying = !this.video.paused;

 this.isChangingQuality = true;
 this.video.pause();

 this.showLoading();
 if (this.video.classList) {
 this.video.classList.add('quality-changing');
 }

 const onLoadedData = () => {
 if (this.options.debug) console.log('Auto quality', targetQuality, 'applied');
 this.video.currentTime = currentTime;
 if (wasPlaying) {
 this.video.play().catch(e => {
 if (this.options.debug) console.log('Autoplay prevented:', e);
 });
 }
 this.currentPlayingQuality = targetQuality;

 this.updateQualityDisplay();

 this.hideLoading();
 if (this.video.classList) {
 this.video.classList.remove('quality-changing');
 }

 this.isChangingQuality = false;
 cleanup();
 };

 const onError = (error) => {
 if (this.options.debug) console.error('Auto quality loading error:', error);
 this.isChangingQuality = false;

 this.onVideoError(error);

 cleanup();
 };

 const cleanup = () => {
 this.video.removeEventListener('loadeddata', onLoadedData);
 this.video.removeEventListener('error', onError);
 };

 this.video.addEventListener('loadeddata', onLoadedData, { once: true });
 this.video.addEventListener('error', onError, { once: true });
 this.video.src = newSource.src;
 this.video.load();
}

setDefaultQuality(quality) {
 if (this.options.debug) console.log(`🔧 Setting defaultQuality: "${quality}"`);
 this.options.defaultQuality = quality;
 this.selectedQuality = quality;

 if (quality === 'auto') {
 this.enableAutoQuality();
 } else {
 this.setQuality(quality);
 }

 return this;
}

getDefaultQuality() {
 return this.options.defaultQuality;
}

getQualityLabel(height, width) {
 if (height >= 2160) return '4K';
 if (height >= 1440) return '1440p';
 if (height >= 1080) return '1080p';
 if (height >= 720) return '720p';
 if (height >= 480) return '480p';
 if (height >= 360) return '360p';
 if (height >= 240) return '240p';
 return `${height}p`;
}

updateAdaptiveQualityMenu() {
 const qualityMenu = this.controls?.querySelector('.quality-menu');
 if (!qualityMenu || !this.isAdaptiveStream) return;

 let menuHTML = `<div class="quality-option ${this.isAutoQuality() ? 'active' : ''}" data-adaptive-quality="auto">Auto</div>`;

 this.adaptiveQualities.forEach(quality => {
 const isActive = this.getCurrentAdaptiveQuality() === quality.index;
 menuHTML += `<div class="quality-option ${isActive ? 'active' : ''}" data-adaptive-quality="${quality.index}">${quality.label}</div>`;
 });

 qualityMenu.innerHTML = menuHTML;
}

updateAdaptiveQualityDisplay() {
 if (!this.isAdaptiveStream) return;

 const qualityBtn = this.controls?.querySelector('.quality-btn');
 if (!qualityBtn) return;

 const isAuto = this.selectedQuality === 'auto' || this.getCurrentAdaptiveQuality() === -1;
 const currentQuality = isAuto ? this.tauto : this.getCurrentAdaptiveQualityLabel();

 const btnText = qualityBtn.querySelector('.quality-btn-text');
 if (btnText) {
 const selectedEl = btnText.querySelector('.selected-quality');
 const currentEl = btnText.querySelector('.current-quality');

 if (selectedEl) {
 selectedEl.textContent = isAuto ? this.tauto : currentQuality;
 }
 if (currentEl) {
 currentEl.textContent = currentQuality;
 }
 }
}

setAdaptiveQuality(qualityIndex) {
 if (!this.isAdaptiveStream) return;

 try {
 if (qualityIndex === 'auto' || qualityIndex === -1) {

 if (this.adaptiveStreamingType === 'dash' && this.dashPlayer) {
 this.dashPlayer.updateSettings({
 streaming: {
 abr: { autoSwitchBitrate: { video: true } }
 }
 });
 } else if (this.adaptiveStreamingType === 'hls' && this.hlsPlayer) {
 this.hlsPlayer.currentLevel = -1; // Auto level selection
 }
 this.selectedQuality = 'auto';
 } else {

 if (this.adaptiveStreamingType === 'dash' && this.dashPlayer) {
 this.dashPlayer.updateSettings({
 streaming: {
 abr: { autoSwitchBitrate: { video: false } }
 }
 });
 this.dashPlayer.setQualityFor('video', qualityIndex);
 } else if (this.adaptiveStreamingType === 'hls' && this.hlsPlayer) {
 this.hlsPlayer.currentLevel = qualityIndex;
 }
 this.selectedQuality = this.adaptiveQualities[qualityIndex]?.label || 'Unknown';
 }

 this.updateAdaptiveQualityDisplay();
 if (this.options.debug) console.log('📡 Adaptive quality set to:', qualityIndex);

 } catch (error) {
 if (this.options.debug) console.error('📡 Error setting adaptive quality:', error);
 }
}

getCurrentAdaptiveQuality() {
 if (!this.isAdaptiveStream) return null;

 try {
 if (this.adaptiveStreamingType === 'dash' && this.dashPlayer) {
 return this.dashPlayer.getQualityFor('video');
 } else if (this.adaptiveStreamingType === 'hls' && this.hlsPlayer) {
 return this.hlsPlayer.currentLevel;
 }
 } catch (error) {
 if (this.options.debug) console.error('📡 Error getting current quality:', error);
 }

 return null;
}

getCurrentAdaptiveQualityLabel() {
 const currentIndex = this.getCurrentAdaptiveQuality();
 if (currentIndex === null || currentIndex === -1) {
 return this.tauto; // Return "Auto" instead of "Unknown"
 }
 return this.adaptiveQualities[currentIndex]?.label || this.tauto;
}

isAutoQuality() {
 if (this.isAdaptiveStream) {
 const currentQuality = this.getCurrentAdaptiveQuality();
 return currentQuality === null || currentQuality === -1 || this.selectedQuality === 'auto';
 }
 return this.selectedQuality === 'auto';
}

setResolution(resolution) {
 if (!this.video || !this.container) {
 if (this.options.debug) console.warn("Video or container not available for setResolution");
 return;
 }

 const supportedResolutions = ["normal", "4:3", "16:9", "stretched", "fit-to-screen", "scale-to-fit"];

 if (!supportedResolutions.includes(resolution)) {
 if (this.options.debug) console.warn(`Resolution "${resolution}" not supported. Supported values: ${supportedResolutions.join(", ")}`);
 return;
 }

 const allResolutionClasses = [
 "resolution-normal", "resolution-4-3", "resolution-16-9",
 "resolution-stretched", "resolution-fit-to-screen", "resolution-scale-to-fit"
 ];

 this.video.classList.remove(...allResolutionClasses);
 if (this.container) {
 this.container.classList.remove(...allResolutionClasses);
 }

 const cssClass = `resolution-${resolution.replace(":", "-")}`;
 this.video.classList.add(cssClass);
 if (this.container) {
 this.container.classList.add(cssClass);
 }

 this.options.resolution = resolution;

 if (this.options.debug) {
 console.log(`Resolution applied: ${resolution} (CSS class: ${cssClass})`);
 }
}

getCurrentResolution() {
 return this.options.resolution || "normal";
}

initializeResolution() {
 if (this.options.resolution && this.options.resolution !== "normal") {
 this.setResolution(this.options.resolution);
 }
}

restoreResolutionAfterQualityChange() {
 if (this.options.resolution && this.options.resolution !== "normal") {
 if (this.options.debug) {
 console.log(`Restoring resolution "${this.options.resolution}" after quality change`);
 }

 setTimeout(() => {
 this.setResolution(this.options.resolution);
 }, 150);
 }
}

initializeSubtitles() {
 this.detectTextTracks();
 this.updateSubtitlesUI();
 this.bindSubtitleEvents();
 this.initializeCustomSubtitles();

 if (this.options.debug) console.log('📝 Detected ' + this.textTracks.length + ' subtitles traces');
}

initializeCustomSubtitles() {

 this.customSubtitles = [];
 this.currentCustomSubtitles = [];
 this.customSubtitlesEnabled = false;
 this.customOverlayElement = null;
 this.customUpdateInterval = null;
 this.currentCustomTrackIndex = -1;

 this.createCustomSubtitleOverlay();
 this.loadCustomSubtitleTracks();

}

createCustomSubtitleOverlay() {
 var existing = document.querySelector('.custom-subtitle-overlay');
 if (existing && existing.parentNode) {
 existing.parentNode.removeChild(existing);
 }

 this.customOverlayElement = document.createElement('div');
 this.customOverlayElement.className = 'custom-subtitle-overlay';

 this.customOverlayElement.style.cssText =
 'position: absolute;' +
 'bottom: 80px;' +
 'left: 50%;' +
 'transform: translateX(-50%);' +
 'z-index: 999;' +
 'color: white;' +
 'font-family: Arial, sans-serif;' +
 'font-size: clamp(12px, 4vw, 18px);' +
 'font-weight: bold;' +
 'text-align: center;' +
 'text-shadow: 2px 2px 4px rgba(0, 0, 0, 1);' +
 'background-color: rgba(0, 0, 0, 0.6);' +
 'padding: 8px 16px;' +
 'border-radius: 6px;' +
 'max-width: 80%;' +
 'line-height: 1.3;' +
 'white-space: pre-line;' +
 'display: none;' +
 'pointer-events: none;' +
 'box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);';

 var playerContainer = this.video.parentElement;
 if (playerContainer) {
 playerContainer.style.position = 'relative';

 if (!playerContainer.style.zIndex) {
 playerContainer.style.zIndex = '1';
 }
 playerContainer.appendChild(this.customOverlayElement);
 }

 if (this.options.debug) console.log('✅ Custom subtitle overlay created with responsive settings');
}

customTimeToSeconds(timeString) {
 if (!timeString) return 0;

 var parts = timeString.split(',');
 if (parts.length !== 2) return 0;

 var time = parts[0];
 var millis = parts[1];

 var timeParts = time.split(':');
 if (timeParts.length !== 3) return 0;

 var hours = parseInt(timeParts[0], 10);
 var minutes = parseInt(timeParts[1], 10);
 var seconds = parseInt(timeParts[2], 10);
 var milliseconds = parseInt(millis, 10);

 if (isNaN(hours) || isNaN(minutes) || isNaN(seconds) || isNaN(milliseconds)) {
 console.error('❌ customTimeToSeconds failed for:', timeString);
 return 0;
 }

 return hours * 3600 + minutes * 60 + seconds + milliseconds / 1000;
}

parseCustomSRT(srtText) {
 var subtitles = [];
 var normalizedText = srtText.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
 var blocks = normalizedText.trim().split('\n\n');

 for (var i = 0; i < blocks.length; i++) {
 var block = blocks[i];
 var lines = block.trim().split('\n');

 if (lines.length >= 3) {
 var timeLine = lines[1].trim();
 var timeMatch = timeLine.match(/(\d{2}:\d{2}:\d{2},\d{3})\s*-->\s*(\d{2}:\d{2}:\d{2},\d{3})/);

 if (timeMatch) {
 var startTime = this.customTimeToSeconds(timeMatch[1]);
 var endTime = this.customTimeToSeconds(timeMatch[2]);
 var text = lines.slice(2).join('\n').trim().replace(/<[^>]*>/g, '');

 if (text && text.length > 0 && startTime < endTime) {
 subtitles.push({
 start: startTime,
 end: endTime,
 text: text
 });
 }
 }
 }
 }

 if (this.options.debug) console.log('✅ Parsed ' + subtitles.length + ' subtitles');
 return subtitles;
}

loadCustomSubtitleTracks() {
 var self = this;
 var tracks = this.video.querySelectorAll('track[kind="subtitles"]');
 if (tracks.length === 0) return;

 tracks.forEach(function (track, index) {
 var src = track.getAttribute('src');
 var label = track.getAttribute('label') || 'Unknown';
 var srclang = track.getAttribute('srclang') || '';

 var trackObj = {
 label: label,
 language: srclang,
 subtitles: [],
 trackIndex: index
 };
 self.customSubtitles.push(trackObj);

 fetch(src)
 .then(function (response) {
 return response.text();
 })
 .then(function (srtText) {
 var normalizedText = srtText.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
 var blocks = normalizedText.trim().split('\n\n');

 for (var i = 0; i < blocks.length; i++) {
 var block = blocks[i].trim();
 if (!block) continue;
 var lines = block.split('\n');

 if (lines.length >= 3) {
 var timeLine = lines[1].trim();
 var timeMatch = timeLine.match(/(\d{2}:\d{2}:\d{2},\d{3})\s*-->\s*(\d{2}:\d{2}:\d{2},\d{3})/);

 if (timeMatch) {
 var startParts = timeMatch[1].split(',');
 var startTimeParts = startParts[0].split(':');
 var startTime = parseInt(startTimeParts[0], 10) * 3600 + parseInt(startTimeParts[1], 10) * 60 + parseInt(startTimeParts[2], 10) + parseInt(startParts[1], 10) / 1000;

 var endParts = timeMatch[2].split(',');
 var endTimeParts = endParts[0].split(':');
 var endTime = parseInt(endTimeParts[0], 10) * 3600 + parseInt(endTimeParts[1], 10) * 60 + parseInt(endTimeParts[2], 10) + parseInt(endParts[1], 10) / 1000;

 var text = lines.slice(2).join('\n').trim().replace(/<[^>]*>/g, '');

 if (text && text.length > 0 && !isNaN(startTime) && !isNaN(endTime) && startTime < endTime) {
 trackObj.subtitles.push({
 start: startTime,
 end: endTime,
 text: text
 });
 }
 }
 }
 }

 if (self.options.debug) {
 console.log('✅ Loaded ' + trackObj.subtitles.length + ' subtitles for ' + label);
 }
 })
 .catch(function (error) {
 console.error('❌ Error loading ' + label + ':', error);
 });
 });
}

sanitizeSubtitleText(text) {
 if (!text) return '';

 var sanitized = text.replace(/<[^>]*>/g, '');

 sanitized = sanitized.replace(/{\\.*?}/g, '');
 sanitized = sanitized.replace(/\\N/g, '\n');

 sanitized = sanitized.replace(/\s+/g, ' ').trim();

 var tempDiv = document.createElement('div');
 tempDiv.innerHTML = sanitized;
 sanitized = tempDiv.textContent || tempDiv.innerText || sanitized;

 return sanitized;
}

enableCustomSubtitleTrack(trackIndex) {
 if (trackIndex < 0 || trackIndex >= this.customSubtitles.length) return false;

 this.disableCustomSubtitles();

 this.customSubtitlesEnabled = true;
 this.currentCustomTrackIndex = trackIndex;
 this.currentCustomSubtitles = this.customSubtitles[trackIndex].subtitles;

 var self = this;
 this.customUpdateInterval = setInterval(function () {
 if (self.customSubtitlesEnabled && self.currentCustomSubtitles.length > 0) {
 self.updateCustomSubtitleDisplay();
 }
 }, 100);

 if (this.options.debug) {
 console.log('✅ Custom subtitles enabled: ' + this.customSubtitles[trackIndex].label);
 }

 return true;
}

updateCustomSubtitleDisplay() {
 if (!this.customSubtitlesEnabled || this.currentCustomSubtitles.length === 0) return;

 var currentTime = this.video.currentTime;
 var currentSubtitle = null;

 for (var i = 0; i < this.currentCustomSubtitles.length; i++) {
 var sub = this.currentCustomSubtitles[i];
 if (currentTime >= sub.start && currentTime <= sub.end) {
 currentSubtitle = sub;
 break;
 }
 }

 if (currentSubtitle) {
 this.customOverlayElement.textContent = currentSubtitle.text;
 this.customOverlayElement.style.display = 'block';
 } else {
 this.customOverlayElement.style.display = 'none';
 this.customOverlayElement.textContent = '';
 }
}

disableCustomSubtitles() {
 this.customSubtitlesEnabled = false;
 this.currentCustomTrackIndex = -1;

 if (this.customOverlayElement) {
 this.customOverlayElement.style.display = 'none';
 this.customOverlayElement.textContent = '';
 }

 if (this.customUpdateInterval) {
 clearInterval(this.customUpdateInterval);
 this.customUpdateInterval = null;
 }

 if (this.options.debug) console.log('❌ Custom subtitles disabled');
}

detectTextTracks() {
 this.textTracks = [];

 if (this.video.textTracks) {
 if (this.options.debug) console.log('🔍 Detecting text tracks... Found: ' + this.video.textTracks.length);

 for (var i = 0; i < this.video.textTracks.length; i++) {
 var track = this.video.textTracks[i];

 if (track.kind === 'subtitles' || track.kind === 'captions') {
 this.textTracks.push({
 track: track,
 label: track.label || 'Track ' + (i + 1),
 language: track.language || 'unknown',
 kind: track.kind,
 index: i
 });
 }
 }

 if (this.options.debug) console.log('📊 Total subtitle tracks detected: ' + this.textTracks.length);
 }
}

enableSubtitleTrack(trackIndex) {
 if (trackIndex < 0 || trackIndex >= this.textTracks.length) return;

 this.disableAllTracks();

 var success = this.enableCustomSubtitleTrack(trackIndex);

 if (success) {
 this.currentSubtitleTrack = this.textTracks[trackIndex].track;
 this.subtitlesEnabled = true;

 if (this.video.textTracks && this.video.textTracks[trackIndex]) {
 this.video.textTracks[trackIndex].mode = 'disabled'; // Keep native disabled
 }

 this.updateSubtitlesButton();
 this.populateSubtitlesMenu();

 if (this.options.debug) {
 console.log('✅ Custom subtitles enabled:', this.textTracks[trackIndex].label);
 }

 this.triggerEvent('subtitlechange', {
 enabled: true,
 trackIndex: trackIndex,
 trackLabel: this.textTracks[trackIndex].label,
 trackLanguage: this.textTracks[trackIndex].language
 });
 } else {
 if (this.options.debug) {
 console.error('❌ Failed to enable custom subtitles for track', trackIndex);
 }
 }
}

disableSubtitles() {
 this.disableCustomSubtitles();
 this.disableAllTracks();

 this.currentSubtitleTrack = null;
 this.subtitlesEnabled = false;

 this.updateSubtitlesButton();
 this.populateSubtitlesMenu();

 if (this.options.debug) console.log('📝 Subtitles disabled');

 this.triggerEvent('subtitlechange', {
 enabled: false,
 trackIndex: -1
 });
}

disableAllTracks() {
 if (!this.video || !this.video.textTracks) return;

 for (var i = 0; i < this.video.textTracks.length; i++) {
 this.video.textTracks[i].mode = 'hidden';
 }

 this.disableCustomSubtitles();
}

getAvailableSubtitles() {
 return this.textTracks.map(function (t) {
 return {
 label: t.label,
 language: t.language,
 kind: t.kind
 };
 });
}

setSubtitleTrack(trackIndex) {
 if (trackIndex === -1) {
 this.disableSubtitles();
 } else {
 this.enableSubtitleTrack(trackIndex);
 }
 return this;
}

getCurrentSubtitleTrack() {
 if (!this.subtitlesEnabled || !this.currentSubtitleTrack) return -1;

 for (var i = 0; i < this.textTracks.length; i++) {
 if (this.textTracks[i].track === this.currentSubtitleTrack) {
 return i;
 }
 }
 return -1;
}

isSubtitlesEnabled() {
 return this.subtitlesEnabled;
}

updateSubtitlesButton() {
 var subtitlesBtn = this.controls && this.controls.querySelector('.subtitles-btn');
 if (!subtitlesBtn) return;

 subtitlesBtn.classList.remove('active');

 if (this.subtitlesEnabled) {
 subtitlesBtn.title = this.t('subtitlesdisable');
 } else {
 subtitlesBtn.title = this.t('subtitlesenable');
 }
}

populateSubtitlesMenu() {
 var subtitlesMenu = this.controls && this.controls.querySelector('.subtitles-menu');
 if (!subtitlesMenu) return;

 var menuHTML = '<div class="subtitles-option ' + (!this.subtitlesEnabled ? 'active' : '') + '" data-track="off">Off</div>';

 for (var i = 0; i < this.textTracks.length; i++) {
 var trackData = this.textTracks[i];
 var isActive = this.currentSubtitleTrack === trackData.track;
 menuHTML += '<div class="subtitles-option ' + (isActive ? 'active' : '') + '" data-track="' + i + '">' + trackData.label + '</div>';
 }

 subtitlesMenu.innerHTML = menuHTML;
}

updateSubtitlesUI() {
 var subtitlesControl = this.controls && this.controls.querySelector('.subtitles-control');

 if (this.textTracks.length > 0 && this.options.showSubtitles) {
 if (subtitlesControl) subtitlesControl.style.display = 'block';
 this.populateSubtitlesMenu();
 } else {
 if (subtitlesControl) subtitlesControl.style.display = 'none';
 }

 this.updateSubtitlesButton();
}

bindSubtitleEvents() {
 var self = this;

 if (this.video.textTracks) {
 this.isChangingSubtitles = false; // flag to prevent loops

 this.video.textTracks.addEventListener('change', function () {

 if (self.isChangingSubtitles) {
 return;
 }

 self.updateSubtitlesUI();
 });
 }

 this.video.addEventListener('timeupdate', () => {
 if (this.customSubtitlesEnabled) {
 this.updateCustomSubtitleDisplay();
 }
 });

 var subtitlesMenu = this.controls && this.controls.querySelector('.subtitles-menu');
 if (subtitlesMenu) {
 subtitlesMenu.addEventListener('click', function (e) {
 var option = e.target.closest('.subtitles-option');
 if (!option) return;

 self.isChangingSubtitles = true; // active flag

 var trackIndex = option.getAttribute('data-track');
 if (trackIndex === 'off') {
 self.disableSubtitles();
 } else {
 self.enableSubtitleTrack(parseInt(trackIndex));
 }

 setTimeout(function () {
 self.isChangingSubtitles = false; // disable flag
 }, 100);
 });
 }
}

handleSubtitlesMenuClick(e) {
 var option = e.target.closest('.subtitles-option');
 if (!option) return; // This prevents button clicks from toggling

 var trackIndex = option.getAttribute('data-track');

 if (trackIndex === 'off') {
 this.disableSubtitles();
 } else {

 this.enableSubtitleTrack(parseInt(trackIndex));
 }

 this.updateSubtitlesButton();
 this.populateSubtitlesMenu();
}

toggleSubtitles() {
 if (this.textTracks.length === 0) return;

 if (this.subtitlesEnabled) {
 this.disableSubtitles();
 } else {
 this.enableSubtitleTrack(0);
 }
}

initializeChapters() {
 if (!this.options.chapters || !Array.isArray(this.options.chapters) && typeof this.options.chapters !== 'string') {
 if (this.options.debug) console.log('📚 No chapters defined');
 return;
 }
 this.chapters = this.parseChapters(this.options.chapters);

 if (this.chapters.length === 0) {
 if (this.options.debug) console.warn('📚 Chapters defined but empty after parsing');
 return;
 }
 this.chapters.sort((a, b) => a.time - b.time);

 if (this.options.debug) console.log('📚 Chapters initialized:', this.chapters);
 this.createChapterMarkers();
 this.createChapterTooltip();
 this.bindChapterEvents();
}

parseChapters(chaptersInput) {
 if (Array.isArray(chaptersInput)) {
 return chaptersInput.map(chapter => this.normalizeChapter(chapter)).filter(c => c !== null);
 }
 if (typeof chaptersInput === 'string') {
 const chapterStrings = chaptersInput.split(',').map(s => s.trim());
 const parsedChapters = [];

 for (const chapterStr of chapterStrings) {
 const parts = chapterStr.split('|').map(p => p.trim());
 if (parts.length < 2) {
 if (this.options.debug) console.warn('📚 Invalid chapter format:', chapterStr);
 continue;
 }

 const chapter = {
 time: this.parseTimeToSeconds(parts[0]),
 title: parts[1],
 image: parts[2] || null
 };

 const normalized = this.normalizeChapter(chapter);
 if (normalized) {
 parsedChapters.push(normalized);
 }
 }

 return parsedChapters;
 }

 if (this.options.debug) console.warn('📚 Invalid chapters format');
 return [];
}

normalizeChapter(chapter) {
 if (!chapter || typeof chapter !== 'object') {
 return null;
 }
 if (!chapter.hasOwnProperty('time') || !chapter.hasOwnProperty('title')) {
 if (this.options.debug) console.warn('📚 Chapter missing required fields:', chapter);
 return null;
 }
 let timeInSeconds = chapter.time;
 if (typeof timeInSeconds === 'string') {
 timeInSeconds = this.parseTimeToSeconds(timeInSeconds);
 }

 if (typeof timeInSeconds !== 'number' || timeInSeconds < 0) {
 if (this.options.debug) console.warn('📚 Invalid chapter time:', chapter.time);
 return null;
 }

 return {
 time: timeInSeconds,
 title: String(chapter.title),
 image: chapter.image || null,
 color: chapter.color || null // Optional custom color
 };
}

parseTimeToSeconds(timeStr) {
 if (typeof timeStr === 'number') {
 return timeStr;
 }

 const parts = String(timeStr).split(':').map(p => parseInt(p.trim(), 10));

 if (parts.length === 3) {
 return parts[0] * 3600 + parts[1] * 60 + parts[2];
 } else if (parts.length === 2) {
 return parts[0] * 60 + parts[1];
 } else if (parts.length === 1) {
 return parts[0];
 }

 return 0;
}

createChapterMarkers() {
 if (!this.progressContainer || !this.video || !this.chapters) {
 return;
 }
 const markersContainer = document.createElement('div');
 markersContainer.className = 'chapter-markers-container';

 this.chapters.forEach((chapter, index) => {
 const marker = document.createElement('div');
 marker.className = 'chapter-marker';
 marker.setAttribute('data-chapter-index', index);
 marker.setAttribute('data-chapter-time', chapter.time);
 marker.setAttribute('data-chapter-title', chapter.title);
 if (chapter.color) {
 marker.style.backgroundColor = chapter.color;
 }

 markersContainer.appendChild(marker);
 });
 this.progressContainer.appendChild(markersContainer);
 this.chapterMarkersContainer = markersContainer;
 if (this.video.duration && !isNaN(this.video.duration)) {
 this.updateChapterMarkerPositions();
 } else {
 const loadedMetadataHandler = () => {
 this.updateChapterMarkerPositions();
 this.video.removeEventListener('loadedmetadata', loadedMetadataHandler);
 };
 this.video.addEventListener('loadedmetadata', loadedMetadataHandler);
 }

 if (this.options.debug) console.log('📚 Chapter markers created on timeline');
}

updateChapterMarkerPositions() {
 if (!this.video || !this.video.duration || !this.chapterMarkersContainer) {
 return;
 }

 const markers = this.chapterMarkersContainer.querySelectorAll('.chapter-marker');
 const duration = this.video.duration;

 markers.forEach((marker, index) => {
 if (this.chapters[index]) {
 const percentage = (this.chapters[index].time / duration) * 100;
 marker.style.left = percentage + '%';
 }
 });

 if (this.options.debug) console.log('📚 Chapter marker positions updated');
}

createChapterTooltip() {
 if (!this.progressContainer) {
 return;
 }

 const tooltip = document.createElement('div');
 tooltip.className = 'chapter-tooltip';
 tooltip.style.opacity = '0';
 tooltip.style.visibility = 'hidden';
 tooltip.innerHTML = `
 <div class="chapter-tooltip-image"></div>
 <div class="chapter-tooltip-title"></div>
 <div class="chapter-tooltip-time"></div>
 `;

 this.progressContainer.appendChild(tooltip);
 this.chapterTooltip = tooltip;

 if (this.options.debug) console.log('📚 Chapter tooltip created');
}

bindChapterEvents() {
 if (!this.chapterMarkersContainer || !this.chapterTooltip) {
 return;
 }
 const markers = this.chapterMarkersContainer.querySelectorAll('.chapter-marker');

 markers.forEach((marker, index) => {
 marker.addEventListener('mouseenter', (e) => {
 this.showChapterTooltip(index, e);
 });

 marker.addEventListener('mousemove', (e) => {
 this.updateChapterTooltipPosition(e);
 });

 marker.addEventListener('mouseleave', () => {
 this.hideChapterTooltip();
 });
 marker.addEventListener('click', (e) => {
 e.stopPropagation();
 this.jumpToChapter(index);
 });
 });
 if (this.video) {
 this.video.addEventListener('timeupdate', () => {
 this.updateActiveChapter();
 });
 }

 if (this.options.debug) console.log('📚 Chapter events bound');
}

showChapterTooltip(chapterIndex, e) {
 if (!this.chapterTooltip || !this.chapters[chapterIndex]) {
 return;
 }

 const chapter = this.chapters[chapterIndex];
 const imageEl = this.chapterTooltip.querySelector('.chapter-tooltip-image');
 const titleEl = this.chapterTooltip.querySelector('.chapter-tooltip-title');
 const timeEl = this.chapterTooltip.querySelector('.chapter-tooltip-time');
 if (chapter.image) {
 imageEl.style.display = 'block';
 imageEl.style.backgroundImage = `url(${chapter.image})`;
 } else {
 imageEl.style.display = 'none';
 }
 titleEl.textContent = chapter.title;
 timeEl.textContent = this.formatTime(chapter.time);
 this.chapterTooltip.style.opacity = '1';
 this.chapterTooltip.style.visibility = 'visible';
 this.updateChapterTooltipPosition(e);
}

updateChapterTooltipPosition(e) {
 if (!this.chapterTooltip || !this.progressContainer) {
 return;
 }

 const rect = this.progressContainer.getBoundingClientRect();
 const tooltipRect = this.chapterTooltip.getBoundingClientRect();
 const mouseX = e.clientX - rect.left;
 let leftPosition = mouseX;
 const tooltipWidth = tooltipRect.width || 200;
 const containerWidth = rect.width;
 leftPosition = Math.max(tooltipWidth / 2, Math.min(containerWidth - tooltipWidth / 2, mouseX));

 this.chapterTooltip.style.left = leftPosition + 'px';
}

hideChapterTooltip() {
 if (!this.chapterTooltip) {
 return;
 }

 this.chapterTooltip.style.opacity = '0';
 this.chapterTooltip.style.visibility = 'hidden';
}

jumpToChapter(chapterIndex) {
 if (!this.video || !this.chapters[chapterIndex]) {
 return;
 }

 const chapter = this.chapters[chapterIndex];
 this.video.currentTime = chapter.time;

 if (this.options.debug) console.log(`📚 Jumped to chapter: ${chapter.title} at ${chapter.time}s`);
 this.triggerEvent('chapterchange', {
 chapterIndex: chapterIndex,
 chapter: chapter,
 currentTime: this.video.currentTime
 });
}

updateActiveChapter() {
 if (!this.video || !this.chapterMarkersContainer || !this.chapters) {
 return;
 }

 const currentTime = this.video.currentTime;
 const markers = this.chapterMarkersContainer.querySelectorAll('.chapter-marker');
 let currentChapterIndex = -1;
 for (let i = this.chapters.length - 1; i >= 0; i--) {
 if (currentTime >= this.chapters[i].time) {
 currentChapterIndex = i;
 break;
 }
 }
 markers.forEach((marker, index) => {
 if (index === currentChapterIndex) {
 marker.classList.add('active');
 } else {
 marker.classList.remove('active');
 }
 });
}

getCurrentChapter() {
 if (!this.video || !this.chapters || this.chapters.length === 0) {
 return null;
 }

 const currentTime = this.video.currentTime;

 for (let i = this.chapters.length - 1; i >= 0; i--) {
 if (currentTime >= this.chapters[i].time) {
 return {
 index: i,
 chapter: this.chapters[i]
 };
 }
 }

 return null;
}

getChapters() {
 return this.chapters || [];
}

getChapterByIndex(index) {
 if (!this.chapters || index < 0 || index >= this.chapters.length) {
 return null;
 }
 return this.chapters[index];
}

nextChapter() {
 const current = this.getCurrentChapter();
 if (!current || current.index >= this.chapters.length - 1) {
 return false;
 }

 this.jumpToChapter(current.index + 1);
 return true;
}

previousChapter() {
 const current = this.getCurrentChapter();
 if (!current) {
 return false;
 }
 if (this.video && this.video.currentTime - current.chapter.time > 3) {
 this.jumpToChapter(current.index);
 return true;
 }
 if (current.index > 0) {
 this.jumpToChapter(current.index - 1);
 return true;
 }

 return false;
}

setChapters(chapters) {
 if (this.chapterMarkersContainer) {
 this.chapterMarkersContainer.remove();
 this.chapterMarkersContainer = null;
 }

 if (this.chapterTooltip) {
 this.chapterTooltip.remove();
 this.chapterTooltip = null;
 }
 this.options.chapters = chapters;
 this.chapters = [];
 this.initializeChapters();

 if (this.options.debug) console.log('📚 Chapters updated dynamically');
}

clearChapters() {
 this.setChapters(null);
}

isFullscreenActive() {
 return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement);
 }

 checkPiPSupport() {
 return 'pictureInPictureEnabled' in document;
 }

 enterFullscreen() {
 const element = this.container.parentElement || this.container;

 if (element.requestFullscreen) {
 element.requestFullscreen();
 } else if (element.webkitRequestFullscreen) {
 element.webkitRequestFullscreen();
 } else if (element.mozRequestFullScreen) {
 element.mozRequestFullScreen();
 }
 }

 exitFullscreen() {
 if (document.exitFullscreen) {
 document.exitFullscreen();
 } else if (document.webkitExitFullscreen) {
 document.webkitExitFullscreen();
 } else if (document.mozCancelFullScreen) {
 document.mozCancelFullScreen();
 }
 }

 async enterPictureInPicture() {
 if (!this.isPiPSupported || !this.video) return;

 try {
 await this.video.requestPictureInPicture();
 } catch (error) {
 if (this.options.debug) console.error('Errore avvio Picture-in-Picture:', error);
 }
 }

 async exitPictureInPicture() {
 if (!this.isPiPSupported) return;

 try {
 await document.exitPictureInPicture();
 } catch (error) {
 if (this.options.debug) console.error('Errore uscita Picture-in-Picture:', error);
 }
 }

 onEnterPiP() {
 if (this.pipIcon) this.pipIcon.classList.add('hidden');
 if (this.pipExitIcon) this.pipExitIcon.classList.remove('hidden');

 if (this.controls) {
 this.controls.style.opacity = '0';
 }

 if (this.titleOverlay) {
 this.titleOverlay.style.opacity = '0';
 }
 }

 onLeavePiP() {
 if (this.pipIcon) this.pipIcon.classList.remove('hidden');
 if (this.pipExitIcon) this.pipExitIcon.classList.add('hidden');

 if (this.controls) {
 this.controls.style.opacity = '';
 }

 if (this.titleOverlay) {
 this.titleOverlay.style.opacity = '';
 }
 }

detectPlaylist() {
 if (!this.options.playlistEnabled) {
 this.isPlaylistActive = false;
 this.hidePlaylistControls();
 return;
 }

 const playlistId = this.video.getAttribute('data-playlist-id');
 const playlistIndex = parseInt(this.video.getAttribute('data-playlist-index'));

 if (playlistId && !isNaN(playlistIndex)) {
 this.playlistId = playlistId;
 this.currentPlaylistIndex = playlistIndex;
 this.loadPlaylistData();
 this.isPlaylistActive = true;
 this.showPlaylistControls();

 if (this.options.debug) {
 console.log(`🎵 Playlist detected: ${playlistId}, video ${playlistIndex}/${this.playlist.length - 1}`);
 }
 } else {
 this.isPlaylistActive = false;
 this.hidePlaylistControls();

 if (this.options.debug) {
 console.log('🎵 No playlist detected');
 }
 }
 }

 loadPlaylistData() {

 const playlistVideos = document.querySelectorAll(`[data-playlist-id="${this.playlistId}"]`);

 this.playlist = Array.from(playlistVideos).map(video => ({
 element: video,
 index: parseInt(video.getAttribute('data-playlist-index')),
 title: video.getAttribute('data-video-title') || `Video ${video.getAttribute('data-playlist-index') || 'Unknown'}`
 })).sort((a, b) => a.index - b.index);

 if (this.options.debug) {
 console.log(`🎵 Loaded playlist with ${this.playlist.length} videos:`,
 this.playlist.map(v => `${v.index}: ${v.title}`));
 }
 }

 nextVideo() {
 if (!this.isPlaylistActive) {
 if (this.options.debug) console.warn('🎵 No playlist active');
 return false;
 }

 let nextIndex = this.currentPlaylistIndex + 1;

 if (nextIndex >= this.playlist.length) {
 if (this.options.playlistLoop) {
 nextIndex = 0;
 } else {
 if (this.options.debug) console.log('🎵 End of playlist reached');
 return false;
 }
 }

 return this.goToPlaylistIndex(nextIndex);
 }

 prevVideo() {
 if (!this.isPlaylistActive) {
 if (this.options.debug) console.warn('🎵 No playlist active');
 return false;
 }

 let prevIndex = this.currentPlaylistIndex - 1;

 if (prevIndex < 0) {
 if (this.options.playlistLoop) {
 prevIndex = this.playlist.length - 1;
 } else {
 if (this.options.debug) console.log('🎵 Beginning of playlist reached');
 return false;
 }
 }

 return this.goToPlaylistIndex(prevIndex);
 }

 goToPlaylistIndex(index) {
 if (!this.isPlaylistActive || index < 0 || index >= this.playlist.length) {
 if (this.options.debug) console.warn(`🎵 Invalid playlist index: ${index}`);
 return false;
 }

 const fromIndex = this.currentPlaylistIndex;
 const targetVideo = this.playlist[index];
 const currentTime = this.video.currentTime || 0;
 const wasPlaying = !this.video.paused;

 this.triggerEvent('playlistchange', {
 fromIndex: fromIndex,
 toIndex: index,
 fromTitle: this.playlist[fromIndex]?.title,
 toTitle: targetVideo.title,
 playlistId: this.playlistId
 });

 if (this.options.debug) {
 console.log(`🎵 Switching from video ${fromIndex} to ${index}: "${targetVideo.title}"`);
 }

 this.switchToVideo(targetVideo.element, wasPlaying);
 this.currentPlaylistIndex = index;
 this.updatePlaylistButtons();

 return true;
 }

 getPlaylistInfo() {
 return {
 isActive: this.isPlaylistActive,
 currentIndex: this.currentPlaylistIndex,
 totalVideos: this.playlist.length,
 playlistId: this.playlistId,
 currentTitle: this.playlist[this.currentPlaylistIndex]?.title || '',
 canGoPrev: this.currentPlaylistIndex > 0 || this.options.playlistLoop,
 canGoNext: this.currentPlaylistIndex < this.playlist.length - 1 || this.options.playlistLoop
 };
 }

 setPlaylistOptions(options = {}) {
 if (options.autoPlay !== undefined) {
 this.options.playlistAutoPlay = options.autoPlay;
 }
 if (options.loop !== undefined) {
 this.options.playlistLoop = options.loop;
 }
 if (options.enabled !== undefined) {
 this.options.playlistEnabled = options.enabled;
 if (!options.enabled) {
 this.hidePlaylistControls();
 this.isPlaylistActive = false;
 } else {
 this.detectPlaylist();
 }
 }

 if (this.isPlaylistActive) {
 this.updatePlaylistButtons();
 }

 if (this.options.debug) {
 console.log('🎵 Playlist options updated:', {
 autoPlay: this.options.playlistAutoPlay,
 loop: this.options.playlistLoop,
 enabled: this.options.playlistEnabled
 });
 }

 return this;
 }

 getPlaylistVideos() {
 return this.playlist.map(video => ({
 index: video.index,
 title: video.title,
 element: video.element,
 isCurrent: video.index === this.currentPlaylistIndex
 }));
 }

initializeWatermark() {
 if (!this.options.watermarkUrl) {
 if (this.options.debug) console.log('🏷️ Watermark disabled - no URL provided');
 return;
 }

 if (this.options.debug) console.log('🏷️ Initializing watermark overlay');
 const watermark = document.createElement('div');
 watermark.className = 'video-watermark';
 const position = this.options.watermarkPosition || 'bottomright';
 watermark.classList.add(`watermark-${position}`); // ← FIX QUI
 if (this.options.hideWatermark) {
 watermark.classList.add('hide-on-autohide');
 }
 const watermarkImg = document.createElement('img');
 watermarkImg.src = this.options.watermarkUrl;
 watermarkImg.alt = 'Watermark';
 if (this.options.watermarkTitle) {
 watermarkImg.title = this.options.watermarkTitle;
 }
 watermarkImg.onerror = () => {
 if (this.options.debug) console.warn('🏷️ Watermark image failed to load:', this.options.watermarkUrl);
 watermark.style.display = 'none';
 };

 watermarkImg.onload = () => {
 if (this.options.debug) console.log('🏷️ Watermark image loaded successfully');
 };
 if (this.options.watermarkLink) {
 watermark.style.cursor = 'pointer';
 watermark.addEventListener('click', (e) => {
 e.stopPropagation(); // Prevent video controls interference
 window.open(this.options.watermarkLink, '_blank', 'noopener,noreferrer');
 if (this.options.debug) console.log('🏷️ Watermark clicked, opening:', this.options.watermarkLink);
 });
 } else {
 watermark.style.cursor = 'default';
 }
 watermark.appendChild(watermarkImg);
 if (this.controls) {
 this.container.insertBefore(watermark, this.controls);
 } else {
 this.container.appendChild(watermark);
 }
 this.watermarkElement = watermark;
 this.updateWatermarkPosition();
 this.watermarkResizeHandler = () => {
 this.updateWatermarkPosition();
 };
 window.addEventListener('resize', this.watermarkResizeHandler);

 if (this.options.debug) {
 console.log('🏷️ Watermark created:', {
 url: this.options.watermarkUrl,
 link: this.options.watermarkLink || 'none',
 position: position,
 title: this.options.watermarkTitle || 'none',
 hideWithControls: this.options.hideWatermark
 });
 }
}

setWatermark(url, link = '', position = 'bottomright', title = '') {
 this.options.watermarkUrl = url;
 this.options.watermarkLink = link;
 this.options.watermarkPosition = position;
 this.options.watermarkTitle = title;
 if (this.watermarkElement) {
 this.watermarkElement.remove();
 this.watermarkElement = null;
 }
 if (url) {
 this.initializeWatermark();
 }

 return this;
}

removeWatermark() {
 if (this.watermarkElement) {
 this.watermarkElement.remove();
 this.watermarkElement = null;
 }
 if (this.watermarkResizeHandler) {
 window.removeEventListener('resize', this.watermarkResizeHandler);
 this.watermarkResizeHandler = null;
 }

 this.options.watermarkUrl = '';
 this.options.watermarkLink = '';
 this.options.watermarkPosition = 'bottomright';
 this.options.watermarkTitle = '';

 if (this.options.debug) console.log('🏷️ Watermark removed');

 return this;
}

setWatermarkPosition(position) {
 if (!['topleft', 'topright', 'bottomleft', 'bottomright'].includes(position)) {
 if (this.options.debug) console.warn('🏷️ Invalid watermark position:', position);
 return this;
 }

 this.options.watermarkPosition = position;

 if (this.watermarkElement) {
 this.watermarkElement.classList.remove(
 'watermark-topleft',
 'watermark-topright',
 'watermark-bottomleft',
 'watermark-bottomright'
 );
 this.watermarkElement.classList.add(`watermark-${position}`); // ← FIX QUI
 }

 if (this.options.debug) console.log('🏷️ Watermark position updated to:', position);

 return this;
}

updateWatermarkPosition() {
 if (!this.watermarkElement) return;
 if (!this.controls) return;

 const position = this.options.watermarkPosition || 'bottomright';
 if (position === 'bottomleft' || position === 'bottomright') {
 const controlsHeight = this.controls.offsetHeight;
 const spacing = 15; // Same spacing used in CSS
 const bottomValue = controlsHeight + spacing;
 const hasControls = this.container.classList.contains('has-controls');

 if (hasControls || !this.options.hideWatermark) {
 this.watermarkElement.style.bottom = `${bottomValue}px`;
 } else {
 this.watermarkElement.style.bottom = '15px';
 }

 if (this.options.debug) {
 console.log(`🏷️ Watermark position updated: bottom ${this.watermarkElement.style.bottom}`);
 }
 }
}

setWatermarkAutoHide(hide) {
 this.options.hideWatermark = hide;

 if (this.watermarkElement) {
 if (hide) {
 this.watermarkElement.classList.add('hide-on-autohide');
 } else {
 this.watermarkElement.classList.remove('hide-on-autohide');
 }
 }

 if (this.options.debug) console.log('🏷️ Watermark auto-hide set to:', hide);

 return this;
}

getWatermarkSettings() {
 return {
 url: this.options.watermarkUrl || '',
 link: this.options.watermarkLink || '',
 position: this.options.watermarkPosition || 'bottomright',
 title: this.options.watermarkTitle || '',
 hideWithControls: this.options.hideWatermark
 };
}

async loadAdaptiveLibraries() {
 if (!this.options.adaptiveStreaming) return false;

 try {

 if (!this.librariesLoaded.dash && !window.dashjs) {
 await this.loadScript(this.options.dashLibUrl);
 this.librariesLoaded.dash = true;
 if (this.options.debug) console.log('📡 Dash.js library loaded');
 }

 if (!this.librariesLoaded.hls && !window.Hls) {
 await this.loadScript(this.options.hlsLibUrl);
 this.librariesLoaded.hls = true;
 if (this.options.debug) console.log('📡 HLS.js library loaded');
 }

 return true;
 } catch (error) {
 if (this.options.debug) console.error('Failed to load adaptive streaming libraries:', error);
 return false;
 }
 }

 detectStreamType(src) {
 if (!src) return null;

 const url = src.toLowerCase();
 if (url.includes('.mpd') || url.includes('dash')) {
 return 'dash';
 } else if (url.includes('.m3u8') || url.includes('hls')) {
 return 'hls';
 }
 return null;
 }

 async initializeAdaptiveStreaming(src) {
 if (!this.options.adaptiveStreaming) return false;

 this.adaptiveStreamingType = this.detectStreamType(src);

 if (!this.adaptiveStreamingType) {
 if (this.options.debug) console.log('📡 No adaptive streaming detected');
 return false;
 }

 const librariesLoaded = await this.loadAdaptiveLibraries();
 if (!librariesLoaded) {
 if (this.options.debug) console.error('📡 Failed to load adaptive libraries');
 return false;
 }

 try {
 if (this.adaptiveStreamingType === 'dash') {
 return await this.initializeDash(src);
 } else if (this.adaptiveStreamingType === 'hls') {
 return await this.initializeHls(src);
 }
 } catch (error) {
 if (this.options.debug) console.error('📡 Adaptive streaming initialization failed:', error);
 return false;
 }

 return false;
 }

 async initializeDash(src) {
 if (!window.dashjs) {
 if (this.options.debug) console.error('📡 Dash.js not available');
 return false;
 }

 try {

 if (this.dashPlayer) {
 this.dashPlayer.destroy();
 }

 this.dashPlayer = window.dashjs.MediaPlayer().create();

 this.dashPlayer.updateSettings({
 streaming: {
 abr: {
 autoSwitchBitrate: {
 video: this.selectedQuality === 'auto'
 }
 },
 text: {
 defaultEnabled: false // Always disable by default
 }
 },
 debug: {
 logLevel: this.options.debug ? window.dashjs.Debug.LOG_LEVEL_DEBUG : window.dashjs.Debug.LOG_LEVEL_ERROR
 }
 });

 this.dashPlayer.on(window.dashjs.MediaPlayer.events.STREAM_INITIALIZED, () => {
 if (this.options.debug) console.log('📡 DASH stream initialized');

 this.disableDashTextTracks();

 this.updateAdaptiveQualities();
 this.isAdaptiveStream = true;
 this.hideLoading();
 });

 this.dashPlayer.on(window.dashjs.MediaPlayer.events.TEXT_TRACKS_ADDED, (e) => {
 if (this.options.debug) {
 console.log('📡 DASH text tracks added:', e);

 if (e.tracks && e.tracks.length > 0) {
 this.dashPlayer.setTextTrack(0);
 }
 } else {

 this.disableDashTextTracks();
 }
 });

 this.dashPlayer.on(window.dashjs.MediaPlayer.events.QUALITY_CHANGE_RENDERED, (e) => {
 if (this.options.debug) console.log('📡 DASH quality changed:', e.newQuality);
 this.updateAdaptiveQualityDisplay();
 });

 this.dashPlayer.initialize(this.video, src, this.options.autoplay);

 setTimeout(() => {
 this.disableDashTextTracks();
 }, 500);

 if (this.options.debug) console.log('📡 DASH player initialized with:', src);
 return true;

 } catch (error) {
 if (this.options.debug) console.error('📡 DASH initialization error:', error);
 return false;
 }
}

disableDashTextTracks() {
 if (!this.dashPlayer) return;

 try {

 if (!this.options.debug) {
 this.dashPlayer.enableText(false);
 this.dashPlayer.setTextTrack(-1);

 if (this.video && this.video.textTracks) {
 for (let i = 0; i < this.video.textTracks.length; i++) {
 this.video.textTracks[i].mode = 'disabled';
 }
 }
 } else {

 this.dashPlayer.enableText(true);
 }
 } catch (error) {
 if (this.options.debug) console.error('📡 Error disabling text tracks:', error);
 }
}

 async initializeHls(src) {
 if (!window.Hls) {
 if (this.options.debug) console.error('📡 HLS.js not available');
 return false;
 }

 if (!window.Hls.isSupported()) {

 if (this.video.canPlayType('application/vnd.apple.mpegurl')) {
 this.video.src = src;
 this.isAdaptiveStream = true;
 if (this.options.debug) console.log('📡 Using native HLS support');
 return true;
 } else {
 if (this.options.debug) console.error('📡 HLS not supported');
 return false;
 }
 }

 try {

 if (this.hlsPlayer) {
 this.hlsPlayer.destroy();
 }

 this.hlsPlayer = new window.Hls({
 debug: this.options.debug,
 enableWorker: true,
 lowLatencyMode: true,
 backBufferLength: 90
 });

 this.hlsPlayer.on(window.Hls.Events.MANIFEST_PARSED, () => {
 if (this.options.debug) console.log('📡 HLS manifest parsed');
 this.updateAdaptiveQualities();
 this.isAdaptiveStream = true;
 this.hideLoading();
 });

 this.hlsPlayer.on(window.Hls.Events.LEVEL_SWITCHED, (event, data) => {
 if (this.options.debug) console.log('📡 HLS level switched:', data.level);
 this.updateAdaptiveQualityDisplay();
 });

 this.hlsPlayer.on(window.Hls.Events.ERROR, (event, data) => {
 if (this.options.debug) console.error('📡 HLS error:', data);
 if (data.fatal) {
 this.handleAdaptiveError(data);
 }
 });

 this.hlsPlayer.loadSource(src);
 this.hlsPlayer.attachMedia(this.video);

 if (this.options.debug) console.log('📡 HLS player initialized with:', src);
 return true;

 } catch (error) {
 if (this.options.debug) console.error('📡 HLS initialization error:', error);
 return false;
 }
 }

 updateAdaptiveQualities() {
 this.adaptiveQualities = [];

 if (this.adaptiveStreamingType === 'dash' && this.dashPlayer) {
 const bitrates = this.dashPlayer.getBitrateInfoListFor('video');
 this.adaptiveQualities = bitrates.map((bitrate, index) => ({
 index: index,
 label: this.getQualityLabel(bitrate.height, bitrate.width),
 height: bitrate.height,
 bandwidth: bitrate.bandwidth
 }));
 } else if (this.adaptiveStreamingType === 'hls' && this.hlsPlayer) {
 const levels = this.hlsPlayer.levels;
 this.adaptiveQualities = levels.map((level, index) => ({
 index: index,
 label: this.getQualityLabel(level.height, level.width),
 height: level.height,
 bandwidth: level.bitrate
 }));
 }

 if (this.options.adaptiveQualityControl) {
 this.updateAdaptiveQualityMenu();
 }

 if (this.options.debug) {
 console.log('📡 Adaptive qualities available:', this.adaptiveQualities);
 }
 }

 handleAdaptiveError(data) {
 if (this.options.debug) console.error('📡 Fatal adaptive streaming error:', data);

 if (this.adaptiveStreamingType === 'hls' && this.hlsPlayer) {
 try {
 this.hlsPlayer.startLoad();
 } catch (error) {
 if (this.options.debug) console.error('📡 Failed to recover from HLS error:', error);
 }
 }
 }

 destroyAdaptivePlayer() {
 try {
 if (this.dashPlayer) {
 this.dashPlayer.destroy();
 this.dashPlayer = null;
 }

 if (this.hlsPlayer) {
 this.hlsPlayer.destroy();
 this.hlsPlayer = null;
 }

 this.isAdaptiveStream = false;
 this.adaptiveStreamingType = null;
 this.adaptiveQualities = [];

 if (this.options.debug) console.log('📡 Adaptive player destroyed');

 } catch (error) {
 if (this.options.debug) console.error('📡 Error destroying adaptive player:', error);
 }
 }

 getAdaptiveStreamingInfo() {
 return {
 isActive: this.isAdaptiveStream,
 type: this.adaptiveStreamingType,
 currentQuality: this.getCurrentAdaptiveQuality(),
 currentQualityLabel: this.getCurrentAdaptiveQualityLabel(),
 availableQualities: this.adaptiveQualities,
 isAuto: this.isAutoQuality()
 };
 }

 setAdaptiveStreamingOptions(options = {}) {
 if (options.enabled !== undefined) {
 this.options.adaptiveStreaming = options.enabled;
 }
 if (options.qualityControl !== undefined) {
 this.options.adaptiveQualityControl = options.qualityControl;
 }
 if (options.dashLibUrl) {
 this.options.dashLibUrl = options.dashLibUrl;
 }
 if (options.hlsLibUrl) {
 this.options.hlsLibUrl = options.hlsLibUrl;
 }

 if (this.options.debug) {
 console.log('📡 Adaptive streaming options updated:', {
 enabled: this.options.adaptiveStreaming,
 qualityControl: this.options.adaptiveQualityControl
 });
 }

 return this;
 }

initializePluginSystem() {
 this.plugins = {};
 this.pluginHooks = {
 'beforeInit': [],
 'afterInit': [],
 'beforePlay': [],
 'afterPlay': [],
 'beforePause': [],
 'afterPause': [],
 'beforeQualityChange': [],
 'afterQualityChange': [],
 'beforeDestroy': [],
 'afterDestroy': []
 };

 if (this.options.debug) {
 console.log('🔌 Plugin system initialized');
 }
 if (this.options.plugins && typeof this.options.plugins === 'object') {
 this.loadPlugins(this.options.plugins);
 }
}

loadPlugins(pluginsConfig) {
 for (const pluginName in pluginsConfig) {
 if (pluginsConfig.hasOwnProperty(pluginName)) {
 const pluginOptions = pluginsConfig[pluginName];
 this.usePlugin(pluginName, pluginOptions);
 }
 }
}

usePlugin(name, options = {}) {
 if (!window.MYETVPlayerPlugins[name]) {
 console.error(`🔌 Plugin "${name}" is not registered. Please load the plugin file first.`);
 return null;
 }
 if (this.plugins[name]) {
 console.warn(`🔌 Plugin "${name}" is already initialized on this player`);
 return this.plugins[name];
 }

 try {
 const PluginClass = window.MYETVPlayerPlugins[name];
 this.triggerPluginEvent('beforepluginsetup', name, options);
 this.triggerPluginEvent(`beforepluginsetup:${name}`, name, options);
 let pluginInstance;

 if (typeof PluginClass === 'function') {
 pluginInstance = new PluginClass(this, options);
 } else if (typeof PluginClass === 'object' && typeof PluginClass.create === 'function') {
 pluginInstance = PluginClass.create(this, options);
 } else {
 throw new Error(`Invalid plugin format for "${name}"`);
 }
 this.plugins[name] = pluginInstance;
 if (typeof pluginInstance.setup === 'function') {
 pluginInstance.setup();
 }
 this.triggerPluginEvent('pluginsetup', name, options);
 this.triggerPluginEvent(`pluginsetup:${name}`, name, options);

 if (this.options.debug) {
 console.log(`🔌 Plugin "${name}" initialized successfully`);
 }

 return pluginInstance;

 } catch (error) {
 console.error(`🔌 Failed to initialize plugin "${name}":`, error);
 return null;
 }
}

getPlugin(name) {
 return this.plugins[name] || null;
}

hasPlugin(name) {
 return !!this.plugins[name];
}

removePlugin(name) {
 if (!this.plugins[name]) {
 console.warn(`🔌 Plugin "${name}" is not initialized on this player`);
 return false;
 }

 try {
 const plugin = this.plugins[name];
 if (typeof plugin.dispose === 'function') {
 plugin.dispose();
 }
 delete this.plugins[name];

 if (this.options.debug) {
 console.log(`🔌 Plugin "${name}" removed successfully`);
 }

 return true;

 } catch (error) {
 console.error(`🔌 Failed to remove plugin "${name}":`, error);
 return false;
 }
}

triggerPluginEvent(eventType, pluginName, data = {}) {
 this.triggerEvent(eventType, {
 pluginName: pluginName,
 ...data
 });
}

registerPluginHook(hookName, callback) {
 if (!this.pluginHooks[hookName]) {
 this.pluginHooks[hookName] = [];
 }

 this.pluginHooks[hookName].push(callback);

 if (this.options.debug) {
 console.log(`🔌 Hook registered: ${hookName}`);
 }
}

executePluginHooks(hookName, data = {}) {
 if (!this.pluginHooks[hookName] || this.pluginHooks[hookName].length === 0) {
 return;
 }

 this.pluginHooks[hookName].forEach(callback => {
 try {
 callback(data);
 } catch (error) {
 console.error(`🔌 Error executing hook "${hookName}":`, error);
 }
 });
}

disposeAllPlugins() {
 const pluginNames = Object.keys(this.plugins);

 pluginNames.forEach(name => {
 this.removePlugin(name);
 });

 if (this.options.debug) {
 console.log('🔌 All plugins disposed');
 }
}

getActivePlugins() {
 return { ...this.plugins };
}

getPluginAPI() {
 return {
 player: this,
 video: this.video,
 container: this.container,
 controls: this.controls,
 play: () => this.play(),
 pause: () => this.pause(),
 togglePlayPause: () => this.togglePlayPause(),
 getCurrentTime: () => this.getCurrentTime(),
 setCurrentTime: (time) => this.setCurrentTime(time),
 getDuration: () => this.getDuration(),
 getVolume: () => this.getVolume(),
 setVolume: (volume) => this.setVolume(volume),
 addEventListener: (eventType, callback) => this.addEventListener(eventType, callback),
 removeEventListener: (eventType, callback) => this.removeEventListener(eventType, callback),
 triggerEvent: (eventType, data) => this.triggerEvent(eventType, data),
 registerHook: (hookName, callback) => this.registerPluginHook(hookName, callback),
 addControlButton: (button) => this.addPluginControlButton(button),
 removeControlButton: (buttonId) => this.removePluginControlButton(buttonId),
 getQualities: () => this.getQualities(),
 setQuality: (quality) => this.setQuality(quality),
 options: this.options,
 debug: (message) => {
 if (this.options.debug) {
 console.log('🔌 Plugin debug:', message);
 }
 }
 };
}

addPluginControlButton(buttonConfig) {
 if (!this.controls) {
 console.error('🔌 Controls not available');
 return null;
 }

 const {
 id,
 icon,
 tooltip,
 position = 'right',
 onClick,
 className = ''
 } = buttonConfig;

 const button = document.createElement('button');
 button.id = id || `plugin-btn-${Date.now()}`;
 button.className = `control-btn plugin-control-btn ${className}`;
 button.setAttribute('aria-label', tooltip || 'Plugin button');
 button.setAttribute('title', tooltip || '');

 if (icon) {
 button.innerHTML = icon;
 }

 if (onClick && typeof onClick === 'function') {
 button.addEventListener('click', (e) => {
 e.stopPropagation();
 onClick(e, this);
 });
 }

 const targetContainer = position === 'left'
 ? this.controls.querySelector('.controls-left')
 : this.controls.querySelector('.controls-right');

 if (targetContainer) {
 targetContainer.appendChild(button);

 if (this.options.debug) {
 console.log(`🔌 Plugin control button added: ${button.id}`);
 }

 return button;
 }

 return null;
}

removePluginControlButton(buttonId) {
 const button = document.getElementById(buttonId);

 if (button) {
 button.remove();

 if (this.options.debug) {
 console.log(`🔌 Plugin control button removed: ${buttonId}`);
 }

 return true;
 }

 return false;
}

getBufferedTime() {
 if (!this.video || !this.video.buffered || this.video.buffered.length === 0) return 0;
 try {
 return this.video.buffered.end(this.video.buffered.length - 1);
 } catch (error) {
 return 0;
 }
 }

 clearTitleTimeout() {
 if (this.titleTimeout) {
 clearTimeout(this.titleTimeout);
 this.titleTimeout = null;
 }
 }

 skipTime(seconds) {
 if (!this.video || !this.video.duration || this.isChangingQuality) return;

 this.video.currentTime = Math.max(0, Math.min(this.video.duration, this.video.currentTime + seconds));
 }

updateTimeDisplay() {

 if (this.currentTimeEl && this.video) {
 this.currentTimeEl.textContent = this.formatTime(this.video.currentTime || 0);
 }

 if (this.durationEl && this.video) {
 const duration = this.video.duration;

 if (!duration || isNaN(duration) || !isFinite(duration)) {

 this.durationEl.innerHTML = '<span class="encoding-badge">Encoding in progress</span>';
 this.durationEl.classList.add('encoding-state');
 } else {

 this.durationEl.textContent = this.formatTime(duration);
 this.durationEl.classList.remove('encoding-state');
 }
 }
}

 formatTime(seconds) {
 if (isNaN(seconds) || seconds < 0) return '0:00';

 const hours = Math.floor(seconds / 3600);
 const minutes = Math.floor((seconds % 3600) / 60);
 const secs = Math.floor(seconds % 60);

 if (hours > 0) {
 return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
 }
 return `${minutes}:${secs.toString().padStart(2, '0')}`;
 }

}

if (typeof module !== "undefined" && module.exports) {
 module.exports = MYETVvideoplayer;
}
if (typeof define === "function" && define.amd) {
 define([], function() { return MYETVvideoplayer; });
}
